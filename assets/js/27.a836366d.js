(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{419:function(e,t,r){e.exports=r.p+"assets/img/sidecar.6a7245df.png"},516:function(e,t,r){"use strict";r.r(t);var n=r(11),o=Object(n.a)({},(function(){var e=this,t=e.$createElement,n=e._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[n("h1",{attrs:{id:"后微服务时代"}},[e._v("后微服务时代")]),e._v(" "),n("div",{staticClass:"custom-block tip"},[n("p",{staticClass:"custom-block-title"},[e._v("后微服务时代")]),e._v(" "),n("p",[e._v("从软件层面独力应对微服务架构问题，发展到软硬一体，合力应对架构问题的时代，此即为“后微服务时代”。")])]),e._v(" "),n("p",[e._v("在微服务中面临的问题，自SOA时代，甚至可以说自原始分布式时代以来就一直存在，注册发现、跟踪治理、负载均衡，传输通讯，等等，这些问题，在分布式系统中都是无可避免的，但这些问题非得由分布式系统自己来解决吗？")]),e._v(" "),n("p",[e._v("我们先不纠结于微服务或者什么别的架构，直接来看待这些问题。如果某个系统需要伸缩扩容，通常会购买新的服务器；如果某个系统需要解决负载均衡问题，通常会布置负载均衡器；如果需要解决传输安全问题，通常会启用TLS传输链路；如果需要解决服务发现问题，通常会设置DNS服务器，等等。之所以微服务时代我们不得不在应用服务层面而不是基础设施层面去解决这些分布式问题，完全是因为由硬件构成的基础设施，跟不上由软件构成的应用服务的灵活性的无奈之举。软件可以只使用键盘就能拆分出不同的服务，只通过拷贝就能够伸缩扩容服务，硬件难道也可以通过敲键盘就变出相应的应用服务器、负载均衡器、DNS服务器、网络链路设施吗！嗯？好像也可以啊？")]),e._v(" "),n("p",[e._v("行为至此，估计大家已经听出下面要说的是"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Virtualization",target:"_blank",rel:"noopener noreferrer"}},[e._v("虚拟化"),n("OutboundLink")],1),e._v("技术和"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/OS-level_virtualization",target:"_blank",rel:"noopener noreferrer"}},[e._v("容器化"),n("OutboundLink")],1),e._v("技术了。微服务时代所取得的成就，本身就离不开以Docker为代表的早期容器化技术的巨大贡献。在此之前，笔者从来没有提器过“容器”二字，这并不是刻意冷落，而是早期的容器只被简单地视为一种可快速启动的服务运行环境，目的是方便于程序的分发部署，这个阶段针对单个服务的容器并未真正参与到分布式问题的解决之中。尽管2014年微服务兴起的时候，Docker Swarm（2013年）和Apache Mesos（2012年）已经存在，更早之前也出现过"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Software-defined_networking",target:"_blank",rel:"noopener noreferrer"}},[e._v("软件定义网络"),n("OutboundLink")],1),e._v("（Software-Defined Networking，SDN）、"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Software-defined_storage",target:"_blank",rel:"noopener noreferrer"}},[e._v("软件定义存储"),n("OutboundLink")],1),e._v("（Software-Defined Storage，SDS）等技术，但是，被业界广泛认可、普遍采用的通过虚拟化的基础设施去解决分布式架构问题的方案，应该要从2017年Kubernetes赢得容器编排战争的胜利开始算起。")]),e._v(" "),n("table",[n("thead",[n("tr",[n("th"),e._v(" "),n("th",[e._v("Kubernetes")]),e._v(" "),n("th",[e._v("Spring Cloud")])])]),e._v(" "),n("tbody",[n("tr",[n("td",[e._v("弹性伸缩")]),e._v(" "),n("td",[e._v("Autoscaling")]),e._v(" "),n("td",[e._v("N/A")])]),e._v(" "),n("tr",[n("td",[e._v("服务发现")]),e._v(" "),n("td",[e._v("KubeDNS  / CoreDNS")]),e._v(" "),n("td",[e._v("Spring Cloud Eureka")])]),e._v(" "),n("tr",[n("td",[e._v("配置中心")]),e._v(" "),n("td",[e._v("ConfigMap / Secret")]),e._v(" "),n("td",[e._v("Spring Cloud Config")])]),e._v(" "),n("tr",[n("td",[e._v("服务网关")]),e._v(" "),n("td",[e._v("Ingress Controller")]),e._v(" "),n("td",[e._v("Spring Cloud Zuul")])]),e._v(" "),n("tr",[n("td",[e._v("负载均衡")]),e._v(" "),n("td",[e._v("Load Balancer")]),e._v(" "),n("td",[e._v("Spring Cloud Ribbon")])]),e._v(" "),n("tr",[n("td",[e._v("服务安全")]),e._v(" "),n("td",[e._v("RBAC API")]),e._v(" "),n("td",[e._v("Spring Cloud Security")])]),e._v(" "),n("tr",[n("td",[e._v("跟踪监控")]),e._v(" "),n("td",[e._v("Metrics API / Dashboard")]),e._v(" "),n("td",[e._v("Spring Cloud Turbine")])]),e._v(" "),n("tr",[n("td",[e._v("降级熔断")]),e._v(" "),n("td",[e._v("N/A")]),e._v(" "),n("td",[e._v("Spring Cloud Hystrix")])])])]),e._v(" "),n("p",[e._v("上表列出了在同一个分布式服务的问题在Spring Cloud中提供的应用层面的解决方案与在Kubernetes中提供的基础设施层面的解决方案，尽管因为各自出发点不同，解决问题的方法和效果都有所差异，但这无疑是提供了一条全新的、前途更加广阔的解题思路。“前途广阔”不仅仅是恭维赞赏，当虚拟化的基础设施从单个服务的容器发展至整个服务集群的所有硬件设施时，软件与硬件的界限便开始模糊。一旦硬件能够跟上软件的灵活性，那些与业务无关的技术性问题便有可能能从软件层面剥离，悄无声息地解决于硬件基础设施之内，让软件得以只专注业务，真正“围绕业务能力构建”。如此，DCE中未能实现的“透明的分布式应用”成为可能，Martin Flower设想的“"),n("a",{attrs:{href:"https://martinfowler.com/bliki/PhoenixServer.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("凤凰服务器"),n("OutboundLink")],1),e._v("“成为可能，Chad Fowler提出的“"),n("a",{attrs:{href:"http://chadfowler.com/2013/06/23/immutable-deployments.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("不可变基础设施"),n("OutboundLink")],1),e._v("”成为可能，从软件层面独力应对分布式架构所带来的各种问题，发展到应用代码与基础设施软硬一体，合力应对架构问题的时代，现在常被媒体冠以“云原生”这个颇为抽象的名字加以宣传。云原生时代与此前微服务时代中追求的目标并没有本质改变，笔者更愿意称其为“后微服务时代”。")]),e._v(" "),n("p",[e._v("Kubernetes成为容器战争胜利者标志着后微服务时代的开端，但Kubernetes并没有能够解决全部的分布式问题，这是因为有一些问题处于应用系统与基础设施的边缘，使得完全在基础设施层面中很难完美地解决。举个例子，譬如微服务A调用了微服务B中发布的两个服务，称为B1和B2，假设B1表现正常但B2出现了持续的500错，那在达到一定阈值之后就应该对B2进行熔断，以避免产生"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Snowball_effect",target:"_blank",rel:"noopener noreferrer"}},[e._v("雪崩效应"),n("OutboundLink")],1),e._v("。如果仅在基础设施层面来处理，这会遇到一个两难问题，切断A到B的网络通路则会影响到B1的正常调用，不切断的话则持续受B2的错误影响。")]),e._v(" "),n("p",[e._v("为了解决这一类问题，微服务基础设施很快进行了第二次进化，引入了今天被称为“"),n("a",{attrs:{href:"https://en.wikipedia.org/wiki/Service_mesh",target:"_blank",rel:"noopener noreferrer"}},[e._v("服务网格"),n("OutboundLink")],1),e._v("”（Service Mesh）的“边车代理模式”（Sidecar Proxy）。所谓的“边车”是一种带垮斗的三轮摩托，我小时候还算常见，现在基本就只在抗日神剧中才会看到了。这里指的意思是会由系统自动在服务容器中注入一个通讯代理服务器（相当于那个挎斗），以类似网络安全里中间人攻击的方式，在应用无感知的情况下，悄然接管掉应用所有对外通讯。这个代理除了实现正常的服务调用通讯外（称为数据平面通讯），同时还接受控制器的指令（称为控制平面通讯），对数据平面通讯的内容进行分析，以实现熔断、认证、度量、监控、负载均衡等各种附加功能。")]),e._v(" "),n("div",{staticClass:"custom-block center"},[n("p",[n("img",{attrs:{src:r(419),alt:""}}),e._v("\n图片来自Istio的"),n("a",{attrs:{href:"https://istio.io/docs/reference/config/policy-and-telemetry/mixer-overview/",target:"_blank",rel:"noopener noreferrer"}},[e._v("配置文档"),n("OutboundLink")],1)])]),e._v(" "),n("p",[e._v("很难从概念上判定清楚一个与应用系统运行于同一容器之内的代理服务到底应该算软件还是算基础设施，但它对应用是透明的，不需要改动任何软件代码就可以实现的服务治理，这便足够了。服务网格在2018年才火起来，今天它仍然是个新潮的概念，仍然未完全成熟，甚至连Kubernetes也还算是个新生事物（以它开源来计算）。但笔者相信，未来几年Kubernetes将会成为服务器端标准的运行环境，如同在此之前Linux；服务网格将会成为微服务之间通讯交互的主流模式，把“选择什么通讯协议”、“如何做认证授权”之类的技术问题隔离于应用软件之外，取代今天Spring Cloud全家桶中大部分组件的功能，微服务只需要考虑业务本身的逻辑。")]),e._v(" "),n("p",[e._v("上帝的归上帝，凯撒的归凯撒，业务与技术完全分离，远程与本地完全透明，也许这就是最好的时代了吧？")])])}),[],!1,null,null,null);t.default=o.exports}}]);