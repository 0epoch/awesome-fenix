<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>安全架构 | 软件架构探索：The Fenix Project</title>
    <meta name="description" content="现代软件架构探索">
    <meta name="generator" content="VuePress 1.4.0">
    <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.e0b309fa.css" as="style"><link rel="preload" href="/assets/js/app.23543073.js" as="script"><link rel="preload" href="/assets/js/2.661f0606.js" as="script"><link rel="preload" href="/assets/js/3.2017d3a0.js" as="script"><link rel="preload" href="/assets/js/9.8542fc4f.js" as="script"><link rel="preload" href="/assets/js/7.7db15abe.js" as="script"><link rel="prefetch" href="/assets/js/10.2fc25f97.js"><link rel="prefetch" href="/assets/js/11.44f36adc.js"><link rel="prefetch" href="/assets/js/12.4f92f68e.js"><link rel="prefetch" href="/assets/js/13.92cac274.js"><link rel="prefetch" href="/assets/js/14.9056776a.js"><link rel="prefetch" href="/assets/js/15.f70007d9.js"><link rel="prefetch" href="/assets/js/16.0c4eda3e.js"><link rel="prefetch" href="/assets/js/17.e603a59d.js"><link rel="prefetch" href="/assets/js/18.5fa247e3.js"><link rel="prefetch" href="/assets/js/19.615b4ddd.js"><link rel="prefetch" href="/assets/js/20.5fcd99ba.js"><link rel="prefetch" href="/assets/js/21.b1ee3c32.js"><link rel="prefetch" href="/assets/js/22.434a0027.js"><link rel="prefetch" href="/assets/js/23.05d02a5b.js"><link rel="prefetch" href="/assets/js/24.47db704d.js"><link rel="prefetch" href="/assets/js/25.e8ca392b.js"><link rel="prefetch" href="/assets/js/26.fbfa45d3.js"><link rel="prefetch" href="/assets/js/27.19b3aff7.js"><link rel="prefetch" href="/assets/js/28.afe6710e.js"><link rel="prefetch" href="/assets/js/29.813b0423.js"><link rel="prefetch" href="/assets/js/30.3abedc9e.js"><link rel="prefetch" href="/assets/js/31.84081bca.js"><link rel="prefetch" href="/assets/js/32.7fb9bada.js"><link rel="prefetch" href="/assets/js/33.a827ef3a.js"><link rel="prefetch" href="/assets/js/34.33c8f6a3.js"><link rel="prefetch" href="/assets/js/35.4022e093.js"><link rel="prefetch" href="/assets/js/36.6e1b9651.js"><link rel="prefetch" href="/assets/js/37.14422443.js"><link rel="prefetch" href="/assets/js/38.ceaf2dce.js"><link rel="prefetch" href="/assets/js/39.2d9e1acd.js"><link rel="prefetch" href="/assets/js/4.918761eb.js"><link rel="prefetch" href="/assets/js/40.086da4e5.js"><link rel="prefetch" href="/assets/js/41.8a77f839.js"><link rel="prefetch" href="/assets/js/42.12e34379.js"><link rel="prefetch" href="/assets/js/43.ff55a6e1.js"><link rel="prefetch" href="/assets/js/44.6ba5b513.js"><link rel="prefetch" href="/assets/js/45.36d27b14.js"><link rel="prefetch" href="/assets/js/46.90d8b51d.js"><link rel="prefetch" href="/assets/js/47.a567d209.js"><link rel="prefetch" href="/assets/js/48.e7398df6.js"><link rel="prefetch" href="/assets/js/49.e10c766e.js"><link rel="prefetch" href="/assets/js/5.5f4be876.js"><link rel="prefetch" href="/assets/js/50.31a45e16.js"><link rel="prefetch" href="/assets/js/51.588a36e8.js"><link rel="prefetch" href="/assets/js/52.76a1df4d.js"><link rel="prefetch" href="/assets/js/53.082c5a2b.js"><link rel="prefetch" href="/assets/js/54.98d0a81e.js"><link rel="prefetch" href="/assets/js/55.15b838ae.js"><link rel="prefetch" href="/assets/js/56.5e93fcff.js"><link rel="prefetch" href="/assets/js/57.de8b4580.js"><link rel="prefetch" href="/assets/js/58.ac3d3403.js"><link rel="prefetch" href="/assets/js/59.2eb03175.js"><link rel="prefetch" href="/assets/js/6.40a3386f.js"><link rel="prefetch" href="/assets/js/60.7d30045f.js"><link rel="prefetch" href="/assets/js/61.0679ae2d.js"><link rel="prefetch" href="/assets/js/62.eb15cbc1.js"><link rel="prefetch" href="/assets/js/63.a608d924.js"><link rel="prefetch" href="/assets/js/64.db872dcf.js"><link rel="prefetch" href="/assets/js/65.d354b22c.js"><link rel="prefetch" href="/assets/js/66.4cc38fa1.js"><link rel="prefetch" href="/assets/js/67.7ea1d85e.js"><link rel="prefetch" href="/assets/js/68.d298575c.js"><link rel="prefetch" href="/assets/js/69.d890ef2f.js"><link rel="prefetch" href="/assets/js/70.ffccff00.js"><link rel="prefetch" href="/assets/js/71.1e5a80b8.js"><link rel="prefetch" href="/assets/js/72.26b6dd14.js"><link rel="prefetch" href="/assets/js/8.7d51c5be.js">
    <link rel="stylesheet" href="/assets/css/0.styles.e0b309fa.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/logo-color.png" alt="软件架构探索：The Fenix Project" class="logo"> <span class="site-name can-hide">软件架构探索：The Fenix Project</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/fenix-bookstore-frontend" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端工程
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/monolithic_arch_springboot" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：单体架构 SpringBoot
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/microservice_arch_springcloud" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：微服务架构 SpringCloud
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/microservice_arch_kubernetes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：微服务架构 Kubernetes
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/serverless_arch_knative" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：无服务架构 Knative
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="http://bookstore.icyfenix.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  示例
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/board.html" class="nav-link">
  讨论区
</a></div> <a href="https://github.com/fenixsoft/awesome-fenix" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/fenix-bookstore-frontend" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端工程
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/monolithic_arch_springboot" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：单体架构 SpringBoot
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/microservice_arch_springcloud" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：微服务架构 SpringCloud
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/microservice_arch_kubernetes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：微服务架构 Kubernetes
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/serverless_arch_knative" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：无服务架构 Knative
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="http://bookstore.icyfenix.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  示例
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/board.html" class="nav-link">
  讨论区
</a></div> <a href="https://github.com/fenixsoft/awesome-fenix" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/introduction/about-me.html" class="sidebar-link">✅ 关于作者</a></li><li><a href="/introduction/about-the-fenix-project.html" class="sidebar-link">✅ 什么是“The Fenix Project”？</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>探索起步</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><a href="/deployment/development-env-setup/" class="sidebar-heading clickable open"><span>✅ 如何开始</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/deployment/development-env-setup/fenix-bookstore-frontend.html" class="sidebar-link">✅ 前端工程</a></li><li><a href="/deployment/development-env-setup/monolithic_arch_springboot.html" class="sidebar-link">✅ 后端工程：SpringBoot</a></li><li><a href="/deployment/development-env-setup/microservice_arch_springcloud.html" class="sidebar-link">后端工程：SpringCloud</a></li><li><a href="/deployment/development-env-setup/microservice_arch_kubernetes.html" class="sidebar-link">后端工程：Kubernetes</a></li><li><a href="/deployment/development-env-setup/serverless_arch_knative.html" class="sidebar-link">后端工程：Knative</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/deployment/deployment-env-setup/" class="sidebar-heading clickable"><span>✅ 环境依赖</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/deployment/deployment-env-setup/setup-docker.html" class="sidebar-link">✅ 部署Docker CE容器环境</a></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><a href="/deployment/deployment-env-setup/setup-kubernetes" class="sidebar-heading clickable"><span>✅ 部署Kubernetes集群</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/deployment/operation-env-setup" class="sidebar-heading clickable"><span>运维环境</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>设计者的视角</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><a href="/architect-perspective/general-architecture" class="sidebar-heading clickable router-link-active open"><span>✅ 架构的普适问题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/architect-perspective/general-architecture/api-style.html" class="sidebar-link">✅ 服务设计风格</a></li><li><a href="/architect-perspective/general-architecture/system-security.html" class="active sidebar-link">✅ 安全架构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/system-security.html#认证" class="sidebar-link">认证</a></li><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/system-security.html#授权" class="sidebar-link">授权</a></li><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/system-security.html#凭证" class="sidebar-link">凭证</a></li><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/system-security.html#保密" class="sidebar-link">保密</a></li><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/system-security.html#传输" class="sidebar-link">传输</a></li><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/system-security.html#验证" class="sidebar-link">验证</a></li><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/system-security.html#漏洞利用" class="sidebar-link">漏洞利用</a></li></ul></li><li><a href="/architect-perspective/general-architecture/transaction.html" class="sidebar-link">✅ 事务一致性</a></li><li><a href="/architect-perspective/general-architecture/diversion-system.html" class="sidebar-link">✅ 透明多级分流系统</a></li><li><a href="/architect-perspective/general-architecture/layered-system.html" class="sidebar-link">系统分层</a></li><li><a href="/architect-perspective/general-architecture/constraint.html" class="sidebar-link">可约束性</a></li><li><a href="/architect-perspective/general-architecture/testability.html" class="sidebar-link">可测试性</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>技巧与专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/architect-perspective/tricks/graalvm-improvement.html" class="sidebar-link">GraalVM：微服务时代的Java</a></li><li><a href="/architect-perspective/tricks/cqrs.html" class="sidebar-link">事件溯源与CQRS</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>演进中的微服务</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/architecture/architect-history.html" class="sidebar-link">服务架构演进史</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/architecture/monolithic-architecture" class="sidebar-heading clickable"><span>单体架构</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/architecture/monolithic-architecture/j2ee-base-arch.html" class="sidebar-link">基于J2EE的单体架构</a></li><li><a href="/architecture/monolithic-architecture/springboot-base-arch.html" class="sidebar-link">基于SpringBoot的单体架构</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/architecture/microservices-architecture" class="sidebar-heading clickable"><span>微服务架构</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/architecture/microservices-architecture/springcloud-base-arch.html" class="sidebar-link">SpringCloud时代的微服务</a></li><li><a href="/architecture/microservices-architecture/kubernetes-base-arch.html" class="sidebar-link">Kubernetes时代的微服务</a></li><li><a href="/architecture/microservices-architecture/servicemesh-lstio-arch.html" class="sidebar-link">后Kubernetes时代的微服务</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/architecture/serverless-architecture" class="sidebar-heading clickable"><span>无服务架构</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/architecture/serverless-architecture/serverless-arch-knative.html" class="sidebar-link">基于Knative的无服务</a></li><li><a href="/architecture/serverless-architecture/serverless-arch-kubeless.html" class="sidebar-link">基于Kubeless的无服务</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>核心技术支撑点</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/technology/service-discovery.html" class="sidebar-link">服务发现</a></li><li><a href="/technology/load-balancing.html" class="sidebar-link">负载均衡</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/technology/invokechain-manage" class="sidebar-heading clickable"><span>链路治理</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/technology/invokechain-manage/traffic-control.html" class="sidebar-link">流控</a></li><li><a href="/technology/invokechain-manage/service-downgrade.html" class="sidebar-link">降级</a></li><li><a href="/technology/invokechain-manage/exception-inject.html" class="sidebar-link">异常注入</a></li><li><a href="/technology/invokechain-manage/invokechain-trace.html" class="sidebar-link">链路跟踪</a></li></ul></section></li><li><a href="/technology/logging.html" class="sidebar-link">日志追踪</a></li><li><a href="/technology/configuration.html" class="sidebar-link">配置中心</a></li><li><a href="/technology/message-queue-bus.html" class="sidebar-link">队列与消息总线</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>不可变基础设施</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><a href="/immutable-infrastructure/network" class="sidebar-heading clickable open"><span>网络</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/immutable-infrastructure/network/kubernetes-cni.html" class="sidebar-link">K8S的CNI网络</a></li><li><a href="/immutable-infrastructure/network/kubernetes-lb.html" class="sidebar-link">K8S的负载均衡</a></li></ul></section></li><li><a href="/immutable-infrastructure/storage.html" class="sidebar-link">共享存储</a></li><li><a href="/immutable-infrastructure/gpu-support.html" class="sidebar-link">GPU虚拟化</a></li><li><a href="/immutable-infrastructure/hardware-schedule.html" class="sidebar-link">硬件资源调度</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/release" class="sidebar-heading clickable"><span>产品发布准备</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/release/build-script.html" class="sidebar-link">构建发布脚本</a></li><li><a href="/release/continuous-integration.html" class="sidebar-link">持续集成</a></li><li><a href="/release/gated-launch.html" class="sidebar-link">灰度发布</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="安全架构">安全架构</h1> <p>即使只限定在“软件架构设计”这个语境下，系统安全仍然是一个很大的话题。我们谈论的计算机系统安全，远不仅指“防御系统被黑客攻击”这样狭隘的“安全”。架构安全性至少应包括了（不限于）以下这些问题的具体解决方案：</p> <ul><li><strong>认证</strong>（Authentication）：系统如何正确分辨出操作用户的真实身份？</li> <li><strong>授权</strong>（ Authorization）：系统如何控制一个用户该看到哪些数据、能操作哪些功能？</li> <li><strong>凭证</strong>（Credentials）：系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</li> <li><strong>保密</strong>（Confidentiality）：系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</li> <li><strong>传输</strong>（Transport Security）：系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</li> <li><strong>验证</strong>（Verification）：系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</li> <li><strong>漏洞利用</strong>（Exploit）<span class="badge warning" style="vertical-align:top;" data-v-15b7b770>编写中</span> ：系统如何避免在基础设施和应用程序中出现弱点，被攻击者利用？</li> <li>……</li></ul> <p>上面这些安全相关的问题，解决起来确实是既繁琐复杂，又难以或缺。值得庆幸的是这一部分内容基本上都是与具体系统、具体业务无关的通用性问题、这意味着它们会存在着业界通行的，已被验证过是行之有效的解决方案，乃至已经形成某一些行业标准，不需要我们自己从头去构思如何解决。后面我们将会通过标准的方案，逐一探讨以上问题的主流处理方法。</p> <p>还有其他一些安全相关的内容，主要由管理、运维、审计方面负责，尽管软件架构也需要配合参与，但不列入本文的讨论范围之中，譬如：安全审计、系统备份与恢复、防治病毒、信息系统安全法规与制度、计算机防病毒制度、保护私有信息规则，等等。</p> <h2 id="认证">认证 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>已完成</span></h2> <div class="custom-block tip"><p class="custom-block-title">认证（Authentication）</p> <p>系统如何正确分辨出操作用户的真实身份？</p></div> <p>“认证”可以说是一个系统中最基础的安全设计，再简陋的系统大概也不大可能省略掉“用户登录”功能。但“认证”这件事情又并不如大多数人所认为的那样，校验一下 用户名、密码是否正确这么简单。尤其是在基于Java的软件系统里，尝试去触接了解Java安全标准的人往往会对一些今天看起来很别扭的概念产生疑惑。在这一部分，将简要概览一下关于认证的主流行业规范、标准；项目中具体如何认证、授权的内容放到下一节去介绍。</p> <p>最初的Java系统里，安全中的“认证”其实是特指“代码级安全”（你是否信任要在你的电脑中运行的代码），这是由“Java 2”之前它的主要应用形式Applets所决定的：从远端下载一段Java代码，以Applet的形式在用户的浏览器中运行，当然要保证这些代码不会损害用户的计算机才行。这一阶段的安全催生了今天仍然存在于Java体系中的“安全管理器”（java.lang.SecurityManager）、“代码权限许可”（java.lang.RuntimePermission）这些概念。</p> <p>不久之后，Java迎来了互联网的迅速兴起，进入了Java第一次快速发展时期，基于超文本的Web应用迅速盖过了“Java 2”时代之前的Applet，此时“安全认证”的重点逐渐转为“用户级安全”（你是否信任正在操作的用户）。在1999年随着J2EE 1.2（它是J2EE的首个版本，版本号直接就是1.2）所发布的Servlet 2.2中增加了一系列认证的API，诸如：</p> <ul><li>HttpServletRequest.isUserInRole()</li> <li>HttpServletRequest.getUserPrincipal()</li> <li>还内置支持了四种硬编码、不可扩展的认证机制：BASIC、FORM、CLIENT-CERT和DIGEST。</li></ul> <p>到Java 1.3时代中，Sun公司提出了同时面向与代码级安全和用户级安全的认证授权服务JAAS（Java Authentication and Authorization Service，1.3处于扩展包中，1.4纳入标准包），不过相对而言，在JAAS中代码级安全仍然是占更主要的地位。</p> <p>由于用户数据可能来自于各种不同的数据源（譬如RDBMS、JNDI、LDAP等等），JAAS设计了一种插入式（Pluggable）的认证和授权模型，以适配各种环境。在今天仍然活跃的主流安全框架中的许多概念，譬如用户叫做“Subject / Principal”、密码存在“Credentials”之中、登陆后从安全上下文“Context”中获取状态等都可以追溯到这一时期所设计的API：</p> <ul><li>LoginModule （javax.security.auth.spi.LoginModule）</li> <li>LoginContext （javax.security.auth.login.LoginContext）</li> <li>Subject （javax.security.auth.Subject）</li> <li>Principal （java.security.Principal）</li> <li>Credentials（javax.security.auth.Destroyable、javax.security.auth.Refreshable）</li></ul> <p>但是，尽管JAAS开创了许多沿用至今的安全概念，实质上并没有得到广泛的应用。这里有两大原因，一方面是由于JAAS同时面向代码级和用户级的安全机制，使得它过度复杂化，难以推广。在这里问题上JCP一直在做着持续的增强和补救，譬如Java EE 6中的JASPIC、Java EE 8中的EE Security：</p> <ul><li>JSR 115：<a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr115/index3.html" target="_blank" rel="noopener noreferrer">Java Authorization Contract for Containers<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（JACC）</li> <li>JSR 196：<a href="https://jcp.org/aboutJava/communityprocess/mrel/jsr196/index2.html" target="_blank" rel="noopener noreferrer">Java Authentication Service Provider Interface for Containers<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（JASPIC）</li> <li>JSR 375： <a href="https://jcp.org/en/jsr/detail?id=375" target="_blank" rel="noopener noreferrer">Java EE Security API<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（EE Security）</li></ul> <p>而另一方面，可能是更重要的一个原因是在21世纪的第一个十年里，以EJB为代表的容器化J2EE与以“Without EJB”为口号、以Spring、Hibernate等为代表的轻量化企业级开发框架之争，以后者的胜利而结束。这也使得依赖于容器安全的JAAS无法得到大多数人的认可。</p> <p>在今时今日，实际活跃于Java届的两大私有的（私有的意思是不由JSR所规范的，即没有java/javax.*作为包名的）的安全框架：</p> <ul><li><a href="https://shiro.apache.org/" target="_blank" rel="noopener noreferrer">Apache Shiro<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li><a href="https://spring.io/projects/spring-security" target="_blank" rel="noopener noreferrer">Spring Security<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <p>相较而言，Shiro使用更为便捷易用，而Spring Security的功能则要复杂强大一些。在我们的项目中（无论是单体架构还是微服务架构），均选择了Spring Security作为安全框架。当然，这里面也有很大一部分是因为Spring Boot/Cloud全家桶的原因。这两大安全框架都解决的问题都很类似，大致可以分为四类：</p> <ul><li>认证：以HTTP协议中定义的各种认证、表单等认证方式确认用户身份，这是本节的主要话题。</li> <li>授权：主要是授权结果，即访问控制（Access Control），稍后讲的“授权”将聚焦在授权的过程，尤其是多方授权中。这部分内容会放到下一节一起讨论。</li> <li>密码的存储：就是字面意思，我们会放到“保密”这节去一起讨论。</li> <li>安全上下文：用户获得认证之后，需要有API可以得知该用户的基本资料、用户拥有的权限、角色等。</li></ul> <p>介绍了一大段关于Java中安全标准的历史，我们最终还是要切入到如何处理认证的话题上，这可是随着网络出现就有的一个东西，所以，IETF的最初想法是基于Web的验证就应该在HTTP协议层面来解决。</p> <div class="quote"><p class="title">互联网工程任务组（Internet Engineering Task Force，IETF）</p><p>管理和发布互联网标准的组织，其标准以RFC即&quot;请求意见稿&quot;Request for Comments的形式发出。不仅是HTTP，几乎目前所有的主要网络协议，如IP、TCP、UDP、FTP、CMIP、SOCKS，等等都是以RFC形式定义的。</p></div><p>IETF给HTTP 1.1协议定义了401（Unauthorized，未授权）状态码，当服务端向客户端返回此状态码时，应在Header中附带一个WWW-Authenticate项，此项目通过跟随的一个可扩展的Scheme，告诉客户端应该采取怎样的方式来开始验证，例如：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token response-status">HTTP/1.1 <span class="token property">401 Unauthorized</span></span>
<span class="token header-name keyword">Date:</span> Mon, 24 Feb 2020 16:50:53 GMT
<span class="token header-name keyword">WWW-Authenticate:</span> Basic realm=&quot;From icyfenix.cn&quot;
</code></pre></div><p>同时，IETF也定义了几种标准的Schema，对应了一些预定义好的认证方式，包括：</p> <ul><li><strong>Basic</strong>：<a href="https://tools.ietf.org/html/rfc7617" target="_blank" rel="noopener noreferrer">RFC 7617<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，HTTP基础认证，弹出一个输入框，把用户名和密码Base64之后发送出去</li> <li><strong>Digest</strong>：<a href="https://tools.ietf.org/html/rfc7616" target="_blank" rel="noopener noreferrer">RFC 7616<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，HTTP摘要认证，弹出一个输入框，把用户名和密码加盐后再通过MD5/SHA等哈希算法摘要后发送出去</li> <li><strong>Bearer</strong>：<a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener noreferrer">RFC 6750<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，OAuth 2.0令牌（OAuth2是一个授权协议，但同时也涉及到认证的内容，下一节的主角）</li> <li><strong>HOBA</strong>：<a href="https://tools.ietf.org/html/rfc7486" target="_blank" rel="noopener noreferrer">RFC 7486<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> ，<strong>H</strong>TTP <strong>O</strong>rigin-<strong>B</strong>ound <strong>A</strong>uthentication的缩写，一种基于数字签名的认证。</li></ul> <p>因为Scheme是允许自定义扩展的，很多厂商也加入了自己的认证方式，譬如：</p> <ul><li><strong>AWS4-HMAC-SHA256</strong>：简单粗暴的名字，一看就是亚马逊AWS基于HMAC-SHA256哈希算法的认证</li> <li><strong>NTLM</strong> / <strong>Negotiate</strong>：微软公司NT LAN Manager（NTLM）用到的两种认证方式</li> <li><strong>Windows Live ID</strong>：这个不需要解释了</li> <li><strong>Twitter Basic</strong>：一个不存在的网站所改良的HTTP基础认证</li> <li>……</li></ul> <p>现在主流的信息系统，直接采用上面这些认证方式比例不算太高，目前的主流仍是Form表单认证，即我们通常所说的“登陆页面”。表单认证并没有什么行业标准可循，表单中的用户字段、密码字段、验证码字段、是否要在客户端加密、加密的方式、接受表单的服务入口等都可由服务端、客户端自行协商决定。</p> <p>在Fenix's Bookstore项目中，我们所设计的登录实质上也是一种表单认证，借用了Spring Security的认证管理器。Spring Security中提供了默认的登陆表单界面和配套的服务，只要在Spring Security的Web安全中简单配置即可启用：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Configuration</span>
<span class="token annotation punctuation">@EnableWebSecurity</span>
<span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">WebSecurityConfig</span> <span class="token keyword">extends</span> <span class="token class-name">WebSecurityConfigurerAdapter</span> <span class="token punctuation">{</span>
    <span class="token annotation punctuation">@Override</span>
    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">configure</span><span class="token punctuation">(</span><span class="token class-name">HttpSecurity</span> http<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>
        http<span class="token punctuation">.</span><span class="token function">authorizeRequests</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">antMatchers</span><span class="token punctuation">(</span><span class="token string">&quot;/&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 首页地址'/'的请求都允许访问</span>
                <span class="token punctuation">.</span><span class="token function">anyRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">authenticated</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 任何请求,登录后才可以访问</span>
                <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">formLogin</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token comment">// 启用表单登录认证，还有另一种httpBasic()方法代表了HTTP基础认证</span>
                <span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 登录页面用户任意访问</span>
                <span class="token punctuation">.</span><span class="token function">and</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
                <span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">permitAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 注销的服务任意访问</span>
    <span class="token punctuation">}</span>    
<span class="token punctuation">}</span>
</code></pre></div><p>Spring Security的权限控制措施在两个层面进行，一种Web级别的访问控制，这是在Web服务器中附加的过滤器（FilterSecurityInterceptor）实现的，另一种是方法级权限控制，是通过动态代理实现的。第二种将在下一节“授权”部分中提及，这里先来说第一种。</p> <p>当Spring Security被启动时（在Spring Boot中通过@EnableWebSecurity注解启动），将会在Web服务器中附加十几个不同作用的过滤器，譬如上面代码就直接涉及到其中三个：</p> <ul><li>SecurityContextPersistenceFilter：用于维护安全上下文，“上下文”说白了就是如果用户登陆了系统，那服务的代码中总该有个地放可以取到当前登陆用户是谁这类信息</li> <li>UsernamePasswordAuthenticationFilter：用于完成用户名、密码的验证过程</li> <li>LogoutFilter：用于注销</li> <li>FilterSecurityInterceptor：用于Web级别的访问控制，如果设置了指定地址需要登陆而实际未登陆，或者设定了需要某些权限才能访问而实际用户并没有，那将抛出AuthenticationException与AccessDeniedException异常</li></ul> <p>让我们再回到上面的代码，这段简单的工作流程是：</p> <ol><li>启用过滤器UsernamePasswordAuthenticationFilter，在其attemptAuthentication()方法中，会从Request中获取用户名和密码，传递给认证管理器AuthenticationManager的authenticate()方法</li> <li>认证管理器的目的是协调不同的用户来源，譬如来自数据库、来自LDAP、来自OAuth等等，每一个用户来源都应该有一个实现了AuthenticationProvider接口并注册到认证管理器的实现类所代表，认证管理器将根据需要，调用对应Provider的authenticate()方法实际完成认证操作。</li> <li>Spring Security默认的Provider是DaoAuthenticationProvider，它在Bookstore项目中并未被采用，而是另外实现了一个UsernamePasswordAuthenticationProvider。但是两者的实际逻辑是相似的，都是调用UserDetailsService接口里的loadUserByUsername()来获取用户信息，UserDetailsService是读取用户明细数据的接口，Spring Security并不关心用户系统的实际存储结构，但认证时肯定也必须使用到用户信息，默认使用InMemoryUserDetailsManager，也就是从内存中写死一些用户数据来完成。</li> <li>在AuthenticationProvider中比较传入的用户密码与数据库中的用户密码是否一致（具体怎么个比较法将在“保密”这一节中说明），返回结果，完成认证。</li></ol> <p>以上流程是大多数系统，尤其是单体系统中主流的认证方式，哪怕不基于Apache Shiro或Spring Security来实现，其思路很可能也是与上面描述的差不多的。但我们的Bookstore却并未直接应用这种认证方式，而是借用了OAuth2授权协议中的密码授权模式，在此过程中完成认证。为何会选择这种方式，以及具体实现部分的内容，将在下一部分“授权”中继续介绍。</p> <h2 id="授权">授权 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>已完成</span></h2> <div class="custom-block tip"><p class="custom-block-title">授权（ Authorization）</p> <p>系统如何控制一个用户该看到哪些数据、能操作哪些功能？</p></div> <p>“授权”这个行为通常伴随着“认证“、”账号“共同出现，并称为AAA（Authentication、Authorization、Account，也有把Account理解为计费的意思）。授权行为在程序中其实非常普遍，我们给一个类、一个方法设置范围控制符（public、protected、private、&lt;Package&gt;），这其实也是一种授权（访问控制）行为。授权涉及到了两个相对独立的问题：</p> <ul><li><p>确保授权的过程可靠：对于单一系统来说，授权的过程是比较容易做到可控的，以前很多语境上提到授权，实质上讲的都是访问控制，理论上两者是应该分开的。而在涉及多方的系统中，授权过程就是一个必须严肃对待的问题：如何即让第三方系统能够访问到所需的资源，又能保证其不泄露用户的敏感数据？现在常用的多方授权协议主要有OAuth2和SAML 2.0（注意这两个协议涵盖的功能并不是直接对等的）。</p></li> <li><p>确保授权的结果可控：授权的结果往往是用于对程序功能或者资源的访问控制（Access Control），形成理论的权限控制模型有：自主访问控制（Discretionary Access Control，DAC）、强制访问控制（Mandatory Access Control，MAC）、基于属性的权限验证（Attribute-Based Access Control，ABAC）还有最为常用，也相对通用的是基于角色的权限模型（Role-Based Access Control，RBAC）。</p></li></ul> <p>由于篇幅原因，在这个小节里我们只介绍（将要）使用到的，也是最常用到的RBAC和OAuth2。先来说较为简单的RBAC。</p> <h3 id="rbac">RBAC</h3> <p>所有的访问控制模型，实质上都是在解决同一个问题：“<strong>谁</strong>（User）”拥有什么&quot;<strong>权限</strong>（Authority）&quot;去操作哪些“<strong>资源</strong>（Resource）”</p> <p>这个问题看起来并不难，最直观的解决方案就是在用户对象上，设定一些操作权限，在使用资源时，检查是否有对应的操作权限即可。是的，请不要因太过简单直接而产生疑惑——Spring Security的访问控制本质上就是这么做的。不过，这种把操作权限直接关联在用户身上的简单设计，在复杂系统上确实会导致比较繁琐的操作。试想一下，如果某个系统涉及到成百上千的资源，又有成千上万的用户，要为每个用户分配合适的权限将带来务必庞大的操作量和极高的出错概率，这也即是RBAC所要解决的问题。</p> <p>为了避免对每一个用户设定权限，RBAC将权限从用户身上剥离，改为绑定到“<strong>角色</strong>（Role）”上，一种我们常见的RBAC应用就是操作系统权限中的“用户组”，这就是一种角色。用户可以隶属与一个或者多个角色，某个角色中也会包含有多个用户，角色之间还可以有继承性（父、子角色的权限继承，RBAC1）。这样，资源的操作就只需按照有限且相对固定的角色去分配操作权限，而不去面对随时会动态增加的用户去分配。当用户的职责发生变化时，在系统中就体现为改变他所隶属的角色，譬如将“普通用户角色”改变“管理员角色”，就可以迅速完成其权限的调整，降低了权限分配错误的风险。RBAC的主要元素之间的关系可以以下图来表示：</p> <div class="mermaid">
graph LR
    User(&quot;用户（User）&quot;) --隶属--&gt; Role(&quot;角色（Role）&quot;) 
    Role --拥有--&gt;Permission(&quot;许可（Permission）&quot;) 
</div> <p>上图中出现了一个新的名词“<strong>许可</strong>（Permission）”。所谓的许可，就是抽象权限的具象化体现。权限在系统中的含义应该是“允许何种<strong>操作</strong>作用于哪些<strong>数据</strong>之上”，这个即为“许可”。举个具体的例子，譬如某个文章管理系统的UserrStory中，与访问控制相关的Backlog可能会是这样描述的：</p> <blockquote><p><strong>Backlog</strong>：</p> <p><strong>周同学</strong>（User）是某SCI杂志的<strong>审稿人</strong>（Role），职责之一是在系统中<strong>审核论文</strong>（Authority）。在<strong>审稿过程</strong>（Session）中，当他认为某篇<strong>论文</strong>（Resource）达到了可以公开发表标准时，就会在后台<strong>点击通过按钮</strong>（Operation）来完成审核。</p></blockquote> <p>以上，“给论文点击通过按钮”就是一种许可（Permission），它是“审核论文”这项权限（Authority）的具象化体现。</p> <p>与微服务架构中的完全遵循RBAC进行访问控制的Kubernetes不同，我们在单体架构中使用的Spring Security参考了但并没有完全按照RBAC来进行设计。Spring Security的设计里用户和角色都可以拥有权限，譬如在HttpSecurity对象上，就同时有着hasRole()和hasAuthority()方法，可能有不少刚接触的人会疑惑，混淆它们之间的关系。在Spring Security的访问控制模型可以认为是下图所示这样的：</p> <div class="mermaid">
graph LR
    User(&quot;用户（User）&quot;) --隶属--&gt; Role(&quot;角色（Role）&quot;) 
    User --赋予--&gt; Authority(&quot;权限（Authority）&quot;)
    Role --拥有--&gt;Permission(&quot;许可（Permission）&quot;) 
    Authority --拥有--&gt; Permission
</div> <p>站在代码实现的角度来看，Spring Security中Role和Authority的差异很小，它们共同存储在同一位置，唯一的差别仅是Role会在存储时自动带上“ROLE_”前缀（可以配置的）罢了。</p> <p>但在使用者的角度来看，Role和Authority的差异可以很大，你可以执行决定你的系统中到底Permission只能对应到角色身上，还是可以让用户也拥有某些角色中没有的权限。这个观点，在Spring Security自己的文档上说的很清楚：这取决于你自己如何使用。</p> <blockquote><p><strong>The core difference between these two is the semantics we attach to how we use the feature.</strong> For the framework, the difference is minimal – and it basically deals with these in exactly the same way.</p></blockquote> <p>使用RBAC，你可以控制最终用户在广义和精细级别上可以做什么。您可以指定用户是管理员，专家用户还是普通用户，并使角色和访问权限与组织中员工的身份职位保持一致。仅根据需要为员工完成工作的足够访问权限来分配权限。</p> <h3 id="oauth2">OAuth2</h3> <p>简要介绍过RBAC，下面我们再来看看相对要复杂繁琐写的OAuth2授权协议（顺带说一下，OAuth1.0已经完全废弃了）。先明确一件事情，OAuth2是一个多方系统中的授权协议，如果你的系统并不涉及到第三方（譬如我们单体架构的Bookstore，即不为第三方提供服务，也不使用第三方的服务），引入OAuth2其实并无必要。我们之所以把OAuth2提前引入，主要是为了给微服务架构做铺垫。</p> <p>OAuth2是在<a href="https://tools.ietf.org/html/rfc6749" target="_blank" rel="noopener noreferrer">RFC 6749<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中定义授权协议，在RFC 6749正文的第一句就明确了OAuth2是解决第三方应用（Third-Party  Application）的授权协议。前面也说到，如果只是单方系统，授权过程是比较容易解决的，至于多方系统授权过程会有什么问题，这里举个现实的例子来说明。</p> <p>譬如你现在正在阅读的这个网站（<a href="https://icyfenix.cn" target="_blank" rel="noopener noreferrer">https://icyfenix.cn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），它的建设和更新大致流程是：笔者以Markdown形式写好了某篇文章，上传到由<a href="https://github.com" target="_blank" rel="noopener noreferrer">GitHub<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供的<a href="https://github.com/fenixsoft/awesome-fenix" target="_blank" rel="noopener noreferrer">代码仓库<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，接着由<a href="https://travis-ci.com" target="_blank" rel="noopener noreferrer">Travis-CI<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>提供的持续集成服务会检测到该仓库发生了变化，触发一次Vuepress编译活动，生成目录和静态的HTML页面，然后推送回GitHub Pages，再触发腾讯云CDN的缓存刷新。这个过程要能顺利进行，就存在一些必须解决的授权问题，Travis-CI只有得到了我的明确授权，GitHub才能同意它读取我代码仓库中的内容，问题是它该如何获得我的授权呢？一种简单粗暴的方案是我把我的用户账号和密码都告诉Travis-CI，但这显然导致了以下这些问题：</p> <ul><li><strong>密码泄漏</strong>：如果Travis-CI被黑客攻破，将导致我GitHub的密码也同时被泄漏</li> <li><strong>访问范围</strong>：Travis-CI将有能力读取、修改、删除、更新我放在GitHub上的所有代码仓库</li> <li><strong>授权回收</strong>：我只有修改密码才能回收授予给Travis-CI的权力，可是我在GitHub的密码只有一个，修改了意味着所有别的第三方的应用程序会全部失效</li></ul> <p>以上出现的这些问题，也就是OAuth2所要解决的问题，尤其是没有HTTPS支持传输安全的环境下依然可以解决这些问题。OAuth2提出的解决办法是通过一个令牌（Token）代替用户密码作为授权的凭证，有了令牌之后，哪怕令牌被泄漏，也不会导致密码的泄漏，令牌上可以设定访问资源的范围以及时效性，每个应用都持有独立的令牌，哪个失效都不会波及其他，一下子上面提出的三个问题都解决了，有了一层令牌之后，整个授权的流程如下图所示：</p> <div class="mermaid" style="margin-bottom:0px;">
sequenceDiagram
    第三方应用-&gt;&gt;+资源所有者: 要求用户给予授权
    资源所有者--&gt;&gt;-第三方应用: 同意给予该应用授权
    第三方应用-&gt;&gt;+授权服务器: 我有用户授权，申请访问令牌
    授权服务器--&gt;&gt;-第三方应用: 同意发放访问令牌
    第三方应用-&gt;&gt;+资源服务器: 我有访问令牌，申请开放资源
    资源服务器--&gt;&gt;-第三方应用: 同意开放资源
</div> <p>这个时序图里面涉及到了OAuth2中几个关键术语，我们通过前面那个具体的上下文语境来解释其含义，这对理解后续几种认证流程十分重要：</p> <ul><li><strong>第三方应用</strong>（Third-Party  Application）：需要得到授权访问我资源的那个应用，即“Travis-CI”</li> <li><strong>授权服务器</strong>（Authorization Server）：能够根据我的意愿提供授权（授权之前肯定已经进行了必要的认证过程，但这在技术上与授权可以没有直接关系）的服务，即“GitHub”</li> <li><strong>资源服务器</strong>（Resource Server）：能够提供第三方应用所需资源的服务（它与认证服务可以是相同的服务器，也可以是不同的服务器），即“代码仓库”</li> <li><strong>资源所有者</strong>（Resource Owner）： 拥有授权权限的人，这里即是“我”</li> <li><strong>操作代理</strong>（User Agent）：指用户用来访问服务器的工具，对于指代人类的“用户”来说这个通常就是浏览器，但在微服务中一个服务经常会作为另一个服务的&quot;用户&quot;，此时指的可能就是HttpClient、RPCClient或者其他访问途径。</li></ul> <p>看来“用令牌代替密码”确实是解决问题的好方法，但这最多只能算个思路，距离执行步骤还是不够具体的，时序图中的“要求/同意授权”、“要求/同意发放令牌”、“要求/同意开放资源”几个服务请求、响应该如何设计，这就是执行步骤的关键了。对此，OAuth2一共提出了四种不同的授权方式（这就是我说OAuth2复杂繁琐的原因，摊手），分别为：</p> <ul><li>授权码模式（Authorization Code）</li> <li>简化模式（Implicit）</li> <li>密码模式（Resource Owner Password Credentials）</li> <li>客户端模式（Client Credentials）</li></ul> <h4 id="授权码模式">授权码模式</h4> <p>授权码模式是四种模式中最严谨（繁琐）的，它考虑到了几乎所有敏感信息泄漏的预防和后果。具体步骤的时序如下：</p> <div class="mermaid" style="margin-bottom:0px;">
sequenceDiagram
	资源所有者 -&gt;&gt; 操作代理: 通过操作代理访问应用
	操作代理 -&gt;&gt; 第三方应用: 遇到需要使用的资源
	第三方应用 -&gt;&gt; 授权服务器: 转向授权服务器的授权页面
	资源所有者 -&gt;&gt;+ 授权服务器: 认证身份，同意授权
	授权服务器 --&gt;&gt;- 操作代理: 返回第三方应用的回调地址，附带授权码
	操作代理 -&gt;&gt; 第三方应用: 转向回调地址
	第三方应用 -&gt;&gt;+ 授权服务器: 将授权码发回给授权服务器，换取访问令牌
	授权服务器 --&gt;&gt;- 第三方应用: 给予访问令牌
	opt  资源访问过程 
		第三方应用 -&gt;&gt;+ 资源服务器: 提供访问令牌
		资源服务器 --&gt;&gt;- 第三方应用: 提供返回资源
		第三方应用 --&gt;&gt; 资源所有者: 返回对资源的处理给用户
	end
</div> <p>在开始完成整个授权过程以前，第三方应用先要到授权服务器上进行注册，所谓注册，是指向认证服务器提供一个域名地址，从授权服务器中获取ClientID和ClientSecret，然后便可以开始如下授权过程：</p> <ol><li>第三方应用将资源所有者（用户）导向授权服务器的授权页面，并向授权服务器提供ClientID及同意授权后的回调URI，这是一次客户端页面转向。</li> <li>授权服务器根据ClientID确认第三方应用的身份，用户在授权服务器中决定是否同意向该身份的应用进行授权（认证的过程在此之前应该已经完成）。</li> <li>如果用户同意授权，授权服务器将转向地第三方应用在第1步调用中提供的回调地址URI，并附带上一个授权码和获取令牌的地址作为参数，这也是一次客户端页面转向。</li> <li>第三方应用通过回调地址收到授权码，然后将授权码与自己的ClientSecret一起作为参数，<strong>通过服务端</strong>向授权服务器提供的获取令牌的服务地址发起请求，换取令牌。该服务端应与注册时提供的域名一直。</li> <li>授权服务器核对授权码和ClientSecret，确认无误后，向第三方应用授予令牌。令牌可以是一个或者两个，其中必定要有的是访问令牌（Access Token），可选的是刷新令牌（Refresh Token）。访问令牌用于到资源服务器获取资源，有效期较短，刷新令牌用于在访问令牌失效后重新获取，有效期较长。</li> <li>资源服务器根据访问令牌所允许的权限，向第三方应用提供资源。</li></ol> <p>这个过程设计，已经考虑到了几乎所有合理的意外情况，举例几个容易想到的：</p> <ul><li>会不会有其他应用冒充第三方应用骗取授权？<br>
ClientID代表一个第三方应用的“用户名”，这个是可以完全公开的。但ClientSecret应当只有应用自己才知道，这个代表了第三方应用的“密码”。在第5步发放令牌时，调用者必须能够提供ClientSecret才能成功完成。只要第三方应用妥善保管好ClientSecret，就没有人能够冒充它。</li> <li>为什么要先发放授权码，再用授权码换令牌？<br>
这是因为客户端转向（通常就是一次HTTP 302重定向）对于用户是可见的，换而言之，授权码完全可能会暴露给用户（以及用户机器上的其他程序），但由于用户并没有ClientSecret，光有授权码也是无法换取到令牌的，所以避免了令牌在传输转向过程中泄漏的风险。</li> <li>为什么要设计一个时限较长的刷新令牌和时限较短的访问令牌？不能直接把访问令牌的时间调长吗？<br>
这是为了缓解OAuth2在<strong>实际应用</strong>中的一个主要缺陷，通常访问令牌一旦发放，除非超过了令牌中的有效期，否则很难（需要付出较大代价）有其他方式让它失效，所以访问令牌的时效性一般设计的比较短（譬如几个小时），如果还需要继续用，那就定期用刷新令牌去更新，授权服务器就可以在更新过程中决定是否还要继续给予授权。至于为什么说很难让它失效，我们将放到下一节“凭证”中解释这一点。</li></ul> <p>尽管授权码模式是严谨的，但是它并不够好用，这不仅仅体现在它那繁复的调用过程上，还体现在它对第三方应用提出了一个具体的要求：必须有服务端（因为第4步要发起服务端转向，而且服务端的地址必须与注册时提供的回调URI在同一个域内）。不要觉得要求一个系统要有服务端是天经地义理所当然的事情，本站的示例程序（<a href="http://bookstore.icyfenix.cn" target="_blank" rel="noopener noreferrer">http://bookstore.icyfenix.cn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）就没有服务端支持，里面使用到了GitHub Issue作为留言板，对GitHub来说照样是第三方应用，需要OAuth2授权来解决。除浏览器外，现在越来越普遍的是移动或桌面端的Client-Side Web Applications，譬如现在大量的基于Cordova、Electron、Node-Webkit.js的应用。所以在此需求里，引出了OAuth2的第二种授权模式：隐式授权。</p> <h4 id="隐式授权">隐式授权</h4> <p>隐式授权省略掉了通过授权码换取令牌的步骤，整个授权过程都不需要服务端支持，一步到位。其代价是在隐式授权中，授权服务器不会再去验证第三方应用的身份（因为没有服务器了，ClientSecret没有人保管，就没有意义了。但其实还是会限制第三方应用的回调URI地址必须与注册时提供的域名一致，有可能被DNS污染之类的攻击所攻破，但仍算是尽人事努力一下）；也不能避免令牌暴露给资源所有者（以及用户机器上可能意图不轨的其他程序、HTTP的中间人攻击等）了。隐私授权的调用时序如下图（从此之后的授权模式，时序中我就不画资源访问部分的内容了，就是前面opt框中的那一部分，以便更聚焦重点）所示：</p> <div class="mermaid" style="margin-bottom:0px;">
sequenceDiagram
	资源所有者 -&gt;&gt; 操作代理: 通过操作代理访问应用
	操作代理 -&gt;&gt; 第三方应用: 遇到需要使用的资源
	第三方应用 -&gt;&gt; 授权服务器: 转向授权服务器的授权页面
	资源所有者 -&gt;&gt; 授权服务器: 认证身份，同意授权
	授权服务器 --&gt;&gt; 操作代理: 返回第三方应用的回调地址，通过Fragment附带访问令牌
	操作代理 -&gt;&gt; 第三方应用: 转向回调地址，通过脚本提取出Fragment中的令牌
</div> <p>在以上过程设计中，与授权码模式模式的显著区别是授权服务器在得到用户授权后，直接返回了访问令牌，这显然降低了安全性，但OAuth2仍然努力尽可能地做到相对安全，譬如在前面提到的隐私授权中，尽管不需要用到服务端，但仍然需要在注册时提供回调域名，此时会要求该域名与接受令牌的域名处于同一个域内。此外，在隐私模式中明确禁止发放刷新令牌。</p> <p>还有一点，在RFC 6749对隐式授权的描述中，特别强调了令牌是“通过Fragment带回”的。部分对超文本协议没有了解的读者，可能不知道<a href="https://en.wikipedia.org/wiki/Fragment_identifier" target="_blank" rel="noopener noreferrer">Fragment<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是个什么东西？</p> <div class="quote"><p class="title">额外知识</p><p>In computer <a href="https://en.wikipedia.org/wiki/Hypertext" target="_blank" rel="noopener noreferrer">hypertext<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, a <strong>fragment identifier</strong> is a <a href="https://en.wikipedia.org/wiki/Character_string_(computer_science)" target="_blank" rel="noopener noreferrer">string<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> of <a href="https://en.wikipedia.org/wiki/Character_(computing)" target="_blank" rel="noopener noreferrer">characters<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> that refers to a <a href="https://en.wikipedia.org/wiki/Resource_(computer_science)" target="_blank" rel="noopener noreferrer">resource<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> that is subordinate to another, primary resource. The primary resource is identified by a <a href="https://en.wikipedia.org/wiki/Uniform_Resource_Identifier" target="_blank" rel="noopener noreferrer">Uniform Resource Identifier<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> (URI), and the fragment identifier points to the subordinate resource.</p></div><p>不想看英文，或者看了觉得概念不好的话，我简单告诉你，Fragment就是地址中&quot;#&quot;号后面的部分，譬如这个地址：</p> <blockquote><p>http://bookstore.icyfenix.cn/#/detail/1</p></blockquote> <p>后面的“/detail/1”便是Fragment，这个语法是在<a href="https://tools.ietf.org/html/rfc3986" target="_blank" rel="noopener noreferrer">RFC 3986<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中定义的标准，规范中解释了这是用于客户端定位的URI从属资源，譬如HTML中就可以使用Fragment来做文档内的跳转（你现在可以点击一下这篇文章左边菜单中的几个子标题，看看浏览器地址的变化）而不会发起服务端请求。此外，如果浏览器对一个带有Fragment的地址发出Ajax请求，那Fragment是不会跟随请求被发送到服务端的，只能在客户端通过Script脚本来读取。所以隐式授权巧妙地利用这个特性，尽最大努力地避免了令牌从操作代理到第三方服务之间的链路存在被攻击的可能性，而被泄漏出去。而认证服务器到到操作代理之间的这一段链路的安全，则可以通过TLS（即HTTPS）来保证没有中间没有受到攻击的，我们可以要求认证服务器都是基于HTTPS的，但无法要求第三方应用都是基于HTTPS。</p> <h4 id="密码模式">密码模式</h4> <p>前面所说的授权码模式和隐私模式，是纯粹的授权模式，它与认证没有直接的关系，如何认证用户的真实身份这是与进行授权互相独立的过程。但在密码模式里，认证和授权就被整合成了同一个过程了。</p> <p>这一种模式原本是只提供给用户对第三方应用是高度可信任的场景之中，譬如第三方应用是操作系统，本应该是不太多见的。但是近年来微服务风潮兴起，反而涌现出了密码模式的一种常见应用形式，譬如微服务群中有一些应用服务与授权服务都是由同一个服务商所搭建的，这自然就可以信任它们了。在单体服务的Fenix's Bookstore实现里，就直接采用了密码模式将认证和授权统一起来，我并不需要担心通过前端代码输入用户名、密码时，前端代码会对这些敏感信息做出什么不轨的行为，因为前端代码虽然在OAuth2中相当于第三方应用的角色，但它也是我本人所提供的，所以不存在信任问题（同时再次说明，如果不是出于方便与其他架构对比的目的，那也不存在引入OAuth2把它当作第三方看待的必要）。密码模式的调用时序就很简单了，如下图所示：</p> <div class="mermaid" style="margin-bottom:0px;">
sequenceDiagram
	资源所有者 -&gt;&gt; 第三方应用: 提供密码凭证
	第三方应用 -&gt;&gt; 授权服务器: 发送用户的密码凭证
	授权服务器 --&gt;&gt; 第三方应用: 发放访问令牌和刷新令牌
</div> <p>显然，在这种模式下，“如何保障安全”的职责无法由OAuth2的过程设计来承担，应是由用户和第三方应用来自行保障了，尽管OAuth2在规范中强调到“此模式下，第三方应用不得保存用户的密码”，但这并没有任何的约束力。</p> <h4 id="客户端模式">客户端模式</h4> <p>客户端模式是四种模式中最简单的，它只涉及到两个主体，第三方应用和授权服务器。严谨一点说，现在叫第三方应用已经不合适的，因为这里已经没有了“第二方”的存在，资源所有者、操作代理都是不存在的。甚至于叫“授权”都不太恰当，资源所有者都没有了，自然也不会有谁授予谁权限的过程。</p> <p>客户端模式是指应用（就不写第三方了）以自己的名义，向授权服务器申请资源许可。这通常用在一些管理或者自动处理形场景之中。举个例子，譬如我开了一家网上书店，因为小本经营，不像京东那样全国多个仓库可以调货，我得保证只要客户成功购买，我就必须有货可发，不能超卖。但经常有人下了订单又拖着不付款，导致部分货物处于冻结状态。所以我写了一个订单清理的定时服务，自动清理掉超过2分钟的未付款的订单。这件UserStory里，订单肯定属于用户自己的资源，如果把订单清理服务看作一个独立的第三方应用的话，他就不应该向用户去申请授权，而应该直接以自己的名义向授权服务器申请一个能清理所有用户订单的授权。客户端模式的时序如下图所示：</p> <div class="mermaid" style="margin-bottom:0px;">
sequenceDiagram
	应用 -&gt;&gt;+ 授权服务器: 申请授权
	授权服务器 --&gt;&gt;- 应用: 发放访问令牌
</div> <p>还有一种与客户端模式类似的授权模式，在<a href="https://tools.ietf.org/html/rfc8628#section-3.4" target="_blank" rel="noopener noreferrer">RFC 8628<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中定义为“设备码模式（Device Code）”，这里顺便简单提一下。设备码模式用于在无输入的情况下区分设备是否允许，典型的应用便是手机锁网解锁（锁网在国内较少，但在国外很常见）或者激活（譬如某游戏机注册到某个游戏平台）的过程。时序如下图所示：</p> <div class="mermaid" style="margin-bottom:0px;">
sequenceDiagram
	设备 -&gt;&gt; 授权服务器: 要求授权
	授权服务器 --&gt;&gt; 设备: 提供验证URI和用户码
	loop 循环直至超时
		设备 -&gt;&gt; 授权服务器: 申请令牌
	end
</div> <p>进行验证时，设备需要从授权服务器获取一个URI地址和一个用户码，然后需要用户手动或设备自动地到验证URI中输入用户码。在这个过程中，设备会一直循环，尝试去获取令牌，直到拿到令牌或者用户码过期为止。</p> <h2 id="凭证">凭证 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>已完成</span></h2> <div class="custom-block tip"><p class="custom-block-title">凭证（Credentials）</p> <p>系统如何保证它与用户之间的承诺是双方当时真实意图的体现，是准确、完整且不可抵赖的？</p></div> <p>在前面介绍OAuth2的内容中，每一种授权模式的目的都是拿到访问令牌，但从未涉及过拿回来的令牌应该长什么样子？反而还挖了一些坑（为何说OAuth2的一个主要缺陷是令牌难以主动失效）还没有填。这节我们讨论凭证，此话题中令牌必须得是主角了，此外，我们还要在这节讨论不使用OAuth2、最传统的方式是如何完成前面所讨论的认证、授权的。</p> <h3 id="cookie-session">Cookie-Session</h3> <p>我们知道，HTTP协议是一种无状态的传输协议，无状态是指协议对事务处理没有上下文的记忆能力，每一个请求都是完全独立的，但是我们中肯定有许多人并没有意识到HTTP协议无状态的重要性。假如你做了一个简单的网页，其中包含了1个HTML、2个Script脚本、3个CSS、还有10张图片，这个网页成功展示在用户屏幕前，需要完成16次与服务端的交互，由于服务器响应的顺序与发送请求的先后没有直接联系，按照可能出现的响应顺序，一共会有P(16,16) = 20922789888000种可能性。试想一下，如果HTML协议不是设计成无状态的，这16次请求各个有依赖关联，先调用哪一个、先返回哪一个，都会对结果产生影响的话，那协调工作会有多么复杂。</p> <p>可是，HTTP协议的无状态特性又有悖于我们最常见的网络应用，譬如认证、授权方面，系统总得要获知用户身份才能提供服务，因此，我们也希望HTTP能有一种手段，让服务器至少有办法能够区分出发送请求的用户是谁。为了实现这个目的，<a href="https://tools.ietf.org/html/rfc6265#section-4.1" target="_blank" rel="noopener noreferrer">RFC 6265<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>规范中定义了HTTP的状态管理机制，在HTTP协议中设计了Set-Cookie指令，该指令的含义是以K/V值对的方式向客户端发送信息，此信息将在此后一定时间内的每次HTTP请求中，以名为Cookie的Header中附带着重新发回服务端，一个典型的Set-Cookie指令如下所示：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token header-name keyword">Set-Cookie:</span> id=icyfenix; Expires=Wed, 21 Feb 2020 07:28:00 GMT; Secure; HttpOnly
</code></pre></div><p>从此以后，当客户端对同一个域名（或者Path）的请求中都会带有值对信息“id=icyfenix”，例如以下所示：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /index.html HTTP/2.0</span>
<span class="token header-name keyword">Host:</span> icyfenix.cn
<span class="token header-name keyword">Cookie:</span> id=icyfenix; sessionid=38afes7a8
</code></pre></div><p>根据每次请求传到服务端的Cookie，服务器就能分辨出请求来自于哪一个用户。由于Cookie是放在请求头上的负载（Payload，这个词后面还要频繁用到），不可能存储太大量的数据，放在Cookie中传输也不安全（被窃取，被篡改），所以通常是不会像例子中“id=icyfenix”这样的直接携带数据的。一般来说，Cookie中一般传输的是一个无意义的不重复的字符串，通常以sessionid或者jsessionid为名，服务器拿这个字符串为Key，再在内存中开辟一块空间，以Key/Entity的结构存储每一个在线用户的上下文状态，并辅以一些超时自动清理的管理措施，这种服务端的状态管理机制就是今天大家耳熟能详的Session，Cookie-Session就是在今天广泛应用于大量系统中的、服务端与客户端联动的状态管理机制。</p> <p>Cookie-Session的方案在本章的主题“安全”上其实多少是占有一定优势的：信息都存储于服务器，不易遭遇传输中被泄漏、篡改的风险，只要通过域保护机制和传输层安全，保证Cookie中的键值不被窃取（如在”漏洞利用“小节中介绍的CSRF、XSS攻击）导致被冒认身份即可。Cookie-Session方案另一大优点是服务端有主动的管理能力，可根据自己的意愿随时修改、清除任意上下文状态，如实现强制某用户下线的功能就很容易。</p> <p>Session-Cookie在单节点单体服务环境中是非常合适的方案，但当服务能力需要水平扩展，要部署集群时就开始面临一些麻烦了，由于Session建立在服务器的内存中，当服务器水平拓展成多节点时，我们必须在以下三种方案中选择其一：</p> <ul><li><p>要么就牺牲集群的一致性（Consistency）能力，让均衡器采用亲和式的负载均衡算法（譬如根据用户IP或者sessionid来分配节点），每一个特定用户发出的所有请求都一直被分配到其中某一个节点来提供服务，每个节点都不重复地保存着一部分用户的状态，如果这个节点崩溃了，里面的用户状态便完全丢失。</p></li> <li><p>要么就牺牲集群的可用性（Availability）能力，让各个节点之间采用复制式的Session，每一个节点中的Session变动都会发送到组播地址的其他服务器上，这样某个节点崩溃了，不会中断都某个用户的服务，但Session之间组播复制的同步代价高昂，节点越多时越是如此。</p></li> <li><p>要么就牺牲集群的分区容错（Partition Tolerance）能力，让普通的服务节点中不再保留状态，将上下文集中放在一个所有服务节点都能访问到的数据节点中进行存储。此时的矛盾是数据节点就成为了单点，一旦数据节点损坏，整个集群都不再能提供服务。（多说一句，现在数据节点常见以Redis来搭建，本身Redis通常也会做集群，但将大集群的CAP问题放到小集群里，并不会让问题的消失，简而言之就是：<a href="https://www.baidu.com/s?wd=%E7%A6%81%E6%AD%A2%E5%A5%97%E5%A8%83%E6%98%AF%E4%BB%80%E4%B9%88%E6%A2%97" target="_blank" rel="noopener noreferrer">禁止套娃<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）</p></li></ul> <p>以后，我们在微服务架构中还会遇到更多分布式的问题，还会经常受到CAP理论（C、A、P必须牺牲一个）的打击，这是一个很值得深入探讨的技术权衡，但毕竟与本章的“安全”关系不大，这里就不再展开了。现在我只想知道一个问题的答案：前面三种方案都有缺陷，那在分布式应用中，就没有能绕过这些问题的解决方案吗？</p> <p>我的答案是：有，也没有。如果说要解决分布式环境下的共享数据的CAP矛盾，这是被数学严格证明了不可能的，所以分布式环境中的状态管理一定会受到CAP的限制。但如果是解决分布式下的认证授权问题，那确实还有一些别的法子可想。前面这句话的言外之意是提醒读者，接下来的JWT令牌与Cookie-Session并不是对等的技术方案，它只解决认证授权问题，充其量能携带少量非敏感的信息，只是Cookie-Session在认证授权问题上的替代品，而不会成为Cookie-Session本身的革命者与继承人。</p> <h3 id="jwt">JWT</h3> <p>前面介绍的Cookie-Session机制在分布式环境下遇到一些问题，在多方系统中，就更不可能谈什么Session层面的数据共享了，而且Cookie也没法跨域。看来，服务器多了，确实不好解决，那就换个思路吧，客户端是唯一的，把数据存储在客户端，每次随着请求发回服务器——JWT就是这种思路的典型代表。</p> <p>JSON Web Token（JWT），定义于<a href="https://tools.ietf.org/html/rfc7519" target="_blank" rel="noopener noreferrer">RFC 7519<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的令牌格式，是目前广泛使用的一种令牌，尤其是与OAuth2配合应用于分布式的、涉及多方的应用系统之中。介绍JWT的具体构成之前，我们先来看一样它是什么样子的，一个JWT的例子如下图所示：</p> <div class="custom-block center"><p><img src="/assets/img/jwt.b07b0d79.png" alt="">
JWT令牌结构</p></div> <p>以上截图来自于网站<a href="https://jwt.io/" target="_blank" rel="noopener noreferrer">https://jwt.io/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，当然，数据是我自己编的。左边的是JWT的本体，它通过名为Authorization的Header发送给服务端，前缀是在<a href="https://tools.ietf.org/html/rfc6750" target="_blank" rel="noopener noreferrer">RFC 6750<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>中定义的bearer，这点在之前关于“认证”的小节中提到过，一个完整的HTTP请求实例如下所示：</p> <div class="language-http extra-class"><pre class="language-http"><code><span class="token request-line"><span class="token property">GET</span> /restful/products/1 HTTP/1.1</span>
<span class="token header-name keyword">Host:</span> icyfenix.cn
<span class="token header-name keyword">Connection:</span> keep-alive
<span class="token header-name keyword">Authorization:</span> bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX25hbWUiOiJpY3lmZW5peCIsInNjb3BlIjpbIkFMTCJdLCJleHAiOjE1ODQ5NDg5NDcsImF1dGhvcml0aWVzIjpbIlJPTEVfVVNFUiIsIlJPTEVfQURNSU4iXSwianRpIjoiOWQ3NzU4NmEtM2Y0Zi00Y2JiLTk5MjQtZmUyZjc3ZGZhMzNkIiwiY2xpZW50X2lkIjoiYm9va3N0b3JlX2Zyb250ZW5kIiwidXNlcm5hbWUiOiJpY3lmZW5peCJ9.539WMzbjv63wBtx4ytYYw_Fo1ECG_9vsgAn8bheflL8
</code></pre></div><p>图中右边的内容是经过Base64URL转码之后的令牌明文，是的，明文，JWT令牌默认是不加密的（你自己要加密也行就，接收时自己解密即可）。从明文中可以看到JWT令牌是以JSON结构（毕竟叫JSON Web Token）存储的，结构上可划分为三个部分，每个部分间用点号“.”分隔开。</p> <p>第一部是<strong>令牌头</strong>（Header），内容如下所示：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;alg&quot;</span><span class="token operator">:</span> <span class="token string">&quot;HS256&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;typ&quot;</span><span class="token operator">:</span> <span class="token string">&quot;JWT&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>它描述了令牌的类型（统一为typ:JWT）和令牌签名的算法，示例中HS256为HMAC SHA256算法的缩写，其他各种系统所支持的签名算法可以参考<a href="https://jwt.io/" target="_blank" rel="noopener noreferrer">https://jwt.io/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>网站所列。</p> <p>第二部分是<strong>负载</strong>（Payload），是令牌真正需要向服务端传递的信息，在认证问题中，至少应该包括告诉服务端“我是谁”的信息，在授权问题中，至少应该包括告诉服务端“我属于什么角色/权限，有哪些许可”。负载部分是可以完全自定义的，根据具体要解决的问题不同，设计自己所需要的信息（但不能太多，毕竟受HTTP Header大小的限制）。一个JWT负载的示例如下所示：</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;username&quot;</span><span class="token operator">:</span> <span class="token string">&quot;icyfenix&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;authorities&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;ROLE_USER&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;ROLE_ADMIN&quot;</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">&quot;scope&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;ALL&quot;</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span>
  <span class="token property">&quot;exp&quot;</span><span class="token operator">:</span> <span class="token number">1584948947</span><span class="token punctuation">,</span>
  <span class="token property">&quot;jti&quot;</span><span class="token operator">:</span> <span class="token string">&quot;9d77586a-3f4f-4cbb-9924-fe2f77dfa33d&quot;</span><span class="token punctuation">,</span>
  <span class="token property">&quot;client_id&quot;</span><span class="token operator">:</span> <span class="token string">&quot;bookstore_frontend&quot;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>而JWT在RF 7519中推荐（无强制约束）了7个声明名称（Claim Name），如有需要用到这些内容，建议字段名与官方的保持一致：</p> <ul><li>iss（Issuer）：签发人</li> <li>exp（Expiration Time）：令牌过期时间</li> <li>sub（Subject）：主题</li> <li>aud （Audience）：令牌受众</li> <li>nbf （Not Before）：令牌生效时间</li> <li>iat （Issued At）：令牌签发时间</li> <li>jti （JWT ID）：令牌编号</li></ul> <p>此外在RFC 8225、RFC 8417、RFC 8485等规范文档，以及OpenID中都定义有约定公有含义的名称，比较多我就不贴出来了，可以参考<a href="https://www.iana.org/assignments/jwt/jwt.xhtml" target="_blank" rel="noopener noreferrer">IANA JSON Web Token Registry<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a> 。</p> <p>第三部分是<strong>签名</strong>（Signature），签名的意思是，使用特定的签名算法（在对象头中公开），使用特定的密钥（Secret，由服务器进行保密，不能公开）对前面两部分内容进行加密计算，以例子中JWT默认的HMAC SHA256算法为例，将通过以下公式产生签名值：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token function">HMACSHA256</span><span class="token punctuation">(</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.&quot;</span> <span class="token operator">+</span> <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span> <span class="token punctuation">,</span> secret<span class="token punctuation">)</span>
</code></pre></div><p>签名的意义在于确保负载中的信息是可信的、没有被篡改的，也没有在传输过程中丢失。因为被签名的内容哪怕发生了一个字节的变动，也会导致整个签名发生显著变化。此外，由于这件事情只能由认证/授权服务器完成（只有它知道Secret），任何人都无法在篡改后重新计算出合法的签名值，所以服务端才能够完全信任客户端传上来的JWT中的负载信息。</p> <p>之前提到了JWT默认采用的签名算法是HMAC SHA256，是一种哈希摘要算法，属于不可逆的“加密”，过程住实质上是不用依赖密钥的，这时候的密钥实际上承担了加盐（Salt）的作用。在多方系统、授权服务与资源服务分离的实际应用中，通常会采用非对称加密算法（典型如RSA）来进行签名，这时候除了授权服务端持有的可以用于签名的私钥外，还会对其他服务器公开一个公钥，公钥不会用来签名，但是能被其他服务用于验证签名是否由私钥所签发的。这样其他服务器也能不依赖授权服务器独立判断JWT令牌中的信息的真伪。在Fenix's Bookstore的单体服务版本中，因为授权与资源服务在同一个服务端，采用了默认的哈希算法来加密签名；而Fenix's Bookstore的微体服务版本，认证授权单独划分出了一个独立的微服务，这时就采用了非对称加密来进行签名了。关于哈希、对称、非对称加密的讨论，将会放到“传输”一节中进行。</p> <p>JWT令牌是多方系统中一种优秀的凭证载体，它不需要任何一个服务节点保留任何一点状态信息，就能够保障认证服务与用户之间的承诺是双方当时真实意图的体现，是准确、完整、不可篡改、且不可抵赖的。同时，由于JWT本身可以携带少量信息，这十分有利于RESTFul API的设计，能够较容易地做成无状态服务，在做水平扩展时就不需要像前面Cookie-Session方案那样考虑如何部署的问题。现实中也确实有一些项目（譬如Fenix's Bookstore）直接采用JWT来承载上下文来实现完全无状态的服务端，这能获得很大的好处，譬如，在你调试Fenix's Bookstore的程序时，随时都可以停止、重启服务端程序，服务重启后客户端仍然是可以毫无感知地继续操作流程；而对于有状态的系统，一般就必须通过再次登录、进行前置业务操作来给服务端重建状态（以上这句话所指的“好处”不是开发时方便重启，而是指不必顾虑状态地增加或者减少服务来进行伸缩）。</p> <p>目前，在大型系统中完全使用JWT来保存上下文状态，服务端完全不持有状态仍是不太现实的，不过将最热点的服务接口单独抽离出来，做成无状态的、幂等的服务，是一种很有效的提升系统吞吐能力的架构设计。这部分内容将在微服务架构的部分如何划分微服务的章节中进一步探讨。</p> <p>JWT并不是没有缺点的完美方案，它存在着以下几个明显或者不明显的缺点：</p> <ul><li><strong>令牌难以主动失效</strong>：JWT令牌一旦签发，理论上就和认证服务器再没有什么瓜葛了，在到期之前就会始终有效，除非服务器部署额外的逻辑，这对某些管理功能的实现是很不利的。譬如，有一种颇为常见的需求是：要求一个用户只能在一台设备上登录，在B设备登陆后，之前已经登录过的A设备就应该自动退出。如果采用JWT，就必须设计一个“黑名单”的额外的逻辑，用来把要主动失效的令牌集中存储起来，而无论这个黑名单是实现在Session、Redis或者数据库中，都会让服务退化回有状态，降低了JWT本身的价值（但黑名单还是很常见的做法，需要维护的黑名单一般是很小的状态量，不少场景中是有存在意义的）。</li> <li><strong>更容易遭受重放攻击</strong>：首先说明Cookie-Session也是有重放攻击问题的，只是因为Session中的数据控制在服务端手上，应对重放攻击会相对主动一些。要在JWT层面解决重放攻击需要付出比较大的代价，无论是加入全局序列号（HTTPS协议的思路）、Nonce字符串（HTTP Digest验证的思路）、挑战应答码（当下网银动态令牌的思路）、还是缩短令牌有效期强制频繁刷新令牌，在真正应用起来时其实都是很麻烦的，真要处理重放攻击，启用HTTPS是正道。</li> <li><strong>只能携带相当有限的数据</strong>：HTTP协议并没有强制约束Header的最大长度，但是，各种服务器（甚至是浏览器）都会有约束，譬如Tomcat就要求Header最大不超过8KB，而在Nginx中则默认为4KB，因此在令牌中存储过多的数据不仅浪费带宽，还有额外的出错风险。</li> <li><strong>令牌在客户端如何存储</strong>：严谨地说，这个并不是JWT的问题而是你的问题。如果授权之后，操作完了关掉浏览器这是结束了，那把令牌放到内存里面，压根不考虑持久化那是最理想的。但并不是谁都能忍受一个网站关闭之后下次就一定强制要重新登陆的（大概也就银行的网站可以忍）。那这样的话，客户端该把令牌存放到哪里？Cookie？localStorage？Indexed DB？它们都有泄漏的可能，而令牌一旦泄漏，别人就可以冒充你的身份做任何事情。</li> <li><strong>无状态也不总是好处</strong>：这个其实不也是JWT的问题。如果不能想像无状态会有什么不好的话，我给你提个需求：请基于无状态JWT的方案，做一个在线用户统计功能。兄弟，难搞哦。</li></ul> <p>我在写这篇文章的时候，在网上搜索资料，发现JWT的争议和吹捧都不少。技术只是工具而已，无论是迷信还是<a href="https://dzone.com/articles/stop-using-jwts-as-session-tokens" target="_blank" rel="noopener noreferrer">使劲黑它<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，都并无必要。</p> <h2 id="保密">保密 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>已完成</span></h2> <div class="custom-block tip"><p class="custom-block-title">保密（Confidentiality）</p> <p>系统如何保证敏感数据无法被包括系统管理员在内的内外部人员所窃取、滥用？</p></div> <p>保密是加密和解密的统称，是以某种特殊的算法改变原有的信息数据，使得未授权的用户即使获得了已加密的信息，但因不知解密的方法，仍然无法了解信息的内容。</p> <p>保密这个话题，按照需要保密信息所处的环节不同，可以划分为“信息在客户端时的保密”、“信息在传输时的保密”和“信息在服务端时的保密”，又或者进一步概括为“端的保密”和“链路的保密”。我们把最复杂、最有效，但却又早就有了标准解决方案的“传输环节”单独提取出来，放到下一个小节去讨论。在本小节中，只讨论两个端的环节，即在客户端和服务端中的信息保密问题，谈一下笔者的几个观点。</p> <h3 id="安全的强度">安全的强度</h3> <p>首先来说一下“安全”的程度问题，保密的安全与否不应该被视为一个离散的二元选项，不是仅有“安全”或者“不安全”的差别，而是随着你的应用所要求的保密程度不同，应该有着不同的安全强度与之对应。这里面说的意思与很多口号中强调的“安全无小事”、“99%安全加1%的漏洞等于零”并不是一码事。我通过以下这些逐步提升的攻击手段和应对措施来解释“安全强度”是意味着什么：</p> <ol><li>给密码做最简单的<a href="https://zh.wikipedia.org/wiki/MD5" target="_blank" rel="noopener noreferrer">MD5<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，如果你的密码本身比较复杂，那一次简单的MD5至少可以保证密码不会被逆推出明文，密码在一个系统中泄漏了不至于威胁到其他系统的使用，但这不能阻止弱密码被<a href="https://zh.wikipedia.org/wiki/%E5%BD%A9%E8%99%B9%E8%A1%A8" target="_blank" rel="noopener noreferrer">彩虹表攻击<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>所逆推。</li> <li>给密码加上固定的盐值，如果给密码加上<a href="https://zh.wikipedia.org/wiki/%E7%9B%90_(%E5%AF%86%E7%A0%81%E5%AD%A6)" target="_blank" rel="noopener noreferrer">盐值<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，可以替弱密码建立一道防御屏障，一定程度上防御已有的彩虹表攻击，但不能阻止加密结果被窃取后（譬如在链路上被抓包了），攻击者直接发送加密结果给服务端进行冒认。</li> <li>给密码加上动态的盐值，如果每次密码向服务端传输时都加入了动态的盐值，让每次加密的结果都不同，那即时传输给服务端的加密密码被窃取了，也无法用来冒认，但这只能保护登录这一个操作，无法阻止对其他功能的<a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB" target="_blank" rel="noopener noreferrer">重放攻击<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>。</li> <li>采用动态令牌与服务端的逻辑配合，可以做到防止重放攻击，依然无法抵御传输过程中被嗅探而泄漏信息的问题（如前面说的在链路上被抓包了）。</li> <li>启用HTTPS（且恰当选择支持的密码学算法、保护好证书），可以防御链路上的恶意嗅探，也在协议层面解决了重放攻击的问题，但它依然存在有被<a href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BA%BA%E6%94%BB%E5%87%BB" target="_blank" rel="noopener noreferrer">中间人攻击<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的可能性、有被证书攻击导致握手失败等风险。</li> <li>……</li></ol> <p>到了第5点，只要做法规范，已经可以抵御不少安全风险了，但也意味着你需要为它付出一些代价（包括加解密的算力，也包括购买证书的费用）。而安全的强度还可以用不同途径继续往上提升，如许多网站会使用手机验证码开辟另一条独立的信息传输渠道来保障安全、如银行会使用有专门物理存储的证书（就是俗称的U盾）来保障安全、如国家电网那样建设遍布全国各地的与公网物理隔离的专用网络来保障安全，等等。显然追求安全强度同时也意味着付出更多代价，肯定不是任何一个网站、系统都需要无限拔高的安全强度。</p> <p>另一个问题是安全强度有尽头吗？存不存在某种绝对安全的保密方式？答案可能出乎多数人的意料，确实是有的。信息论之父香农严格证明了一次性密码（One Time Password）的绝对安全性。但是使用一次性密码必须有个前提，就是先把安全的把密码（密码列表）传达给对方。譬如，给你的朋友（人肉）送去一本存储了完全随机密码的密码本，然后每次使用其中一条密码来进行加密通讯，用完一条丢弃一条，理论上这是绝对安全的，但显然这对于公众互联网是没有任何的可执行性。</p> <h3 id="客户端加密">客户端加密</h3> <p>客户端在用户登录、注册一类场景里是否需要对密码进行加密，这个问题一直存有争议。我的观点是，为了保证密码不被黑客窃取而做客户端加密没有太多意义，上HTTPS可以说是唯一的普通系统实际可行的解决方案。但是！为了保证密码不在服务端被滥用，在客户端就开始加密是很有意义的。大网站被拖库的事情层出不穷，密码明文被写入数据库、被输出到日志中之类的事情屡见不鲜，做系统设计时就应该把明文密码这种东西当成是最烫手的山芋来看待，越早消灭掉越好。</p> <p>关于第一个“没有太多意义”，有人不理解为什么为什么客户端加密对防御黑客会没有意义，我举个例子，在极端情况下，客户端可能被整个架空掉，这样上面无论做了什么防御措施都成“马其诺防线”了。典型的就是之前已经提到的中间人攻击，它可以通过劫持掉了客户端到服务端之间的某个节点，包括但不限于代理（通过HTTP代理返回赝品）、路由器（通过路由导向赝品）、DNS服务（直接将你机器的DNS查询结果替换为赝品地址）等等，把你要访问的登陆页面整个给替换掉（全替换掉工作量太大，一般不会去做，都是注入一段恶意的JavaScript代码到正版的页面里）。最简单的劫持路由器，在局域网内其他机器释放ARP病毒便有可能做到这一点。这部分内容属于链路安全，我们将在下一节来讲如何防御，这里附带<a href="https://developer.mozilla.org/zh-CN/docs/Glossary/MitM" target="_blank" rel="noopener noreferrer">Mozilla<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>对中间人攻击的一段介绍以供参考。</p> <div class="quote"><p class="title">中间人攻击（Man-in-the-Middle Attack，MitM）</p><p>在消息发出方和接收方之间拦截双方通讯。用日常生活中的写信来类比的话：你给朋友写了一封信，邮递员可以把每一份你寄出去的信都拆开看，甚至把信的内容改掉，然后重新封起来，再寄出去给你的朋友。朋友收到信之后给你回信，邮递员又可以拆开看，看完随便改，改完封好再送到你手上。你全程都不知道自己寄出去的信和收到的信都经过邮递员这个“中间人”转手和处理——换句话说，对于你和你朋友来讲，邮递员这个“中间人”角色是不可见的。</p></div><p>关于第二个“很有意义”，居然也有人会抬杠。一种是说涉及到密码等敏感信息的都会由靠谱的人完成，或者就是他本人做的，所以不会出问题，我觉得这个就没什么必要反驳了，开心就好。另一种的观点是保存明文密码（把不含盐的哈希结果也作明文看待）的目的是为了便于客户端做动态盐值，因为这需要服务端存储了明文才能每次用新的盐值重新加密来与客户端传上来的加密结果进行比较。我的观点是每次从服务端请求盐值在客户端动态加盐往往会得不偿失，应在真正防御性的密码加密存储应该在服务端进行，因为客户端无轮是否动态加盐，都不能代替HTTPS。</p> <h3 id="密码存储和验证">密码存储和验证</h3> <p>下面以Fenix's Bookstore的实现为具体样例，介绍从密码如何从客户端传输到服务端，存储进数据库的全过程。在保障一定安全强度的同时，避免消耗过多的运算资源，验证起来也比较便捷。这套过程对于一般的系统，配合一定的约束（如密码要求长度、特殊字符等），再配合HTTPS传输应该是够用的。即使在客户采用了弱密码、客户端盐值泄漏（本来就不是保密的）、服务端被拖库泄漏了存储的密文和动态盐值这些问题同时发生，也没有用户明文密码被逆推出来的风险。</p> <p>以下为密码创建的过程，</p> <ol><li><p>用户在客户端注册，输入明文密码：123456。</p> <div class="language-java extra-class"><pre class="language-java"><code>password <span class="token operator">=</span> <span class="token number">123456</span>
</code></pre></div></li> <li><p>客户端对用户密码进行简单Hash，可选的算法有MD2/4/5、SHA1/256/512、BCrypt、PBKDF1/2，等等。</p> <div class="language-java extra-class"><pre class="language-java"><code>client_hash <span class="token operator">=</span> <span class="token function">MD5</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token comment">// e10adc3949ba59abbe56e057f20f883e</span>
</code></pre></div></li> <li><p>为了防御彩虹表攻击，应加盐处理，客户端加盐可取固定的字符串，或者伪动态（日期、用户名加上固定字符串，反正就是服务端不需要额外通讯可以得到的值）的盐值。</p> <div class="language-java extra-class"><pre class="language-java"><code>client_hash <span class="token operator">=</span> <span class="token function">MD5</span><span class="token punctuation">(</span><span class="token function">MD5</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token operator">+</span> salt<span class="token punctuation">)</span>  <span class="token comment">// SALT = $2a$10$o5L.dWYEjZjaejOmN3x4Qu</span>
</code></pre></div></li> <li><p>我们假设攻击者截获了传输，把哈希值和盐值都拿到了，那他可以枚举遍历所有10位数以内（10位数只是举个例子，反正就是弱密码，你拿1024位随机字符当密码用，加不加盐，彩虹表都跟你没任何关系）的弱密码，然后对每个密码再加盐计算，得到一个固定盐值的对照彩虹表。为了应对这种暴力破解，我们需要引入慢哈希函数来代替MD5来加强安全性。<br>慢哈希函数是指这个函数执行时间（准确地说是运算次数）是可以调节的，BCrypt算法就是一种慢哈希函数，在做哈希时接收盐值salt和执行成本cost两个参数（代码层面cost一般是混入在salt中，譬如上面例子中的salt就是混入了10轮运算的盐值，10轮的意思是2<sup>10</sup>次哈希，cost参数是放在指数上的，最大取值就31）。如果我们控制BCrypt的执行时间大概是0.1秒完成一次哈希计算的话，按照1秒生成10个哈希的速度，算完所有的10位大小写字母和数字组成的弱密码大概需要P(62,10)/(3600*24*365)/0.1=1,237,204,169年。</p> <div class="language-java extra-class"><pre class="language-java"><code>client_hash <span class="token operator">=</span> <span class="token class-name">BCrypt</span><span class="token punctuation">(</span><span class="token function">MD5</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span> <span class="token operator">+</span> salt<span class="token punctuation">)</span>  <span class="token comment">// MFfTW3uNI4eqhwDkG7HP9p2mzEUu/r2</span>
</code></pre></div></li> <li><p>现在将哈希传输到服务端，链路这段安全在下一节去探讨。<br>服务端接受到哈希值后，对每一个密码都动态生成一个随机盐值。比较主流的建议是采用“<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%AD%A6%E5%AE%89%E5%85%A8%E4%BC%AA%E9%9A%8F%E6%9C%BA%E6%95%B0%E7%94%9F%E6%88%90%E5%99%A8" target="_blank" rel="noopener noreferrer">密码学安全伪随机数生成器<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Cryptographically Secure Pseudo-Random Number Generator，CSPRNG）”来产生一个长度与哈希值相等的随机字符串。对于Java语言，从Java SE 7起提供了java.security.SecureRandom类，用于支持CSPRNG字符串生成。</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token class-name">SecureRandom</span> random <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SecureRandom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">byte</span> server_salt<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
random<span class="token punctuation">.</span><span class="token function">nextBytes</span><span class="token punctuation">(</span>server_salt<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">// tq2pdxrblkbgp8vt8kbdpmzdh1w8bex</span>
</code></pre></div></li> <li><p>将盐混入客户端传来的哈希值，生成要存入数据库的密文，并将随机生成的盐值一并写入到同一条记录中。在服务端中就不建议采用慢哈希算法，对CPU占用率的影响较大，Spring Security 5的StandardPasswordEncoder提供了SHA256哈希算法的实现，就以此为例。</p> <div class="language-java extra-class"><pre class="language-java"><code>server_hash <span class="token operator">=</span> <span class="token function">SHA256</span><span class="token punctuation">(</span>client_hash <span class="token operator">+</span> server_salt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 55b4b5815c216cf80599990e781cd8974a1e384d49fbde7776d096e1dd436f67</span>
DB<span class="token punctuation">.</span><span class="token function">save</span><span class="token punctuation">(</span>server_hash<span class="token punctuation">,</span> server_salt<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>（可选）出于对SHA256安全性的不信任，Spring Security 5中StandardPasswordEncoder已被@Deprecated，介意或者想偷懒简化操作的话，推荐第5、6步采用BCryptPasswordEncoder来替代。尽管使用的是BCrypt算法，但默认构造函数中的cost是-1，即进行2<sup>-1</sup>=1次哈希计算，这并不会造成服务端压力。说可以偷懒是因为用BCryptPasswordEncoder的话就不需要专门传入盐值，它本身就会调用CSPRNG产生盐值，也不需要给数据库添加盐值字段了，在它生成密码的前32位自动存储了盐值。</p></li></ol> <p>以下为密码验证的过程：</p> <ol><li><p>客户端，用户在登陆页面中输入密码明文：123456，经过与注册相同的加密过程，向服务端传输加密后的结果。</p> <div class="language-java extra-class"><pre class="language-java"><code>authentication_hash <span class="token operator">=</span> <span class="token class-name">MFfTW3uNI4eqhwDkG7HP9p2mzEUu</span><span class="token operator">/</span>r2
</code></pre></div></li> <li><p>服务端，接受到客户端传输上来的哈希值，从数据库中取出登陆用户对应的密文和盐值，采用服务端的哈希算法，对客户端传来的哈希值、服务端盐值计算出哈希结果。</p> <div class="language-java extra-class"><pre class="language-java"><code>result <span class="token operator">=</span> <span class="token function">SHA256</span><span class="token punctuation">(</span>authentication_hash <span class="token operator">+</span> server_salt<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 55b4b5815c216cf80599990e781cd8974a1e384d49fbde7776d096e1dd436f67</span>
</code></pre></div></li> <li><p>比较上一步的结果和数据库储存的哈希值是否相同，如果相同那么密码正确，反之密码错误。</p> <div class="language-java extra-class"><pre class="language-java"><code>authentication <span class="token operator">=</span> <span class="token function">compare</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> server_hash<span class="token punctuation">)</span> <span class="token comment">// yes</span>
</code></pre></div></li></ol> <h2 id="传输">传输 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>已完成</span></h2> <div class="custom-block tip"><p class="custom-block-title">传输（Transport Security）</p> <p>系统如何保证通过网络传输的信息无法被第三方窃听、篡改和冒充？</p></div> <p>这节的主角是签名、证书、TLS等，但不会涉及“到哪找免费的CA证书？”、“如何生成数字证书？”、“如何把证书置入Web服务器？”这一类操作性的话题，而更多是对整套传输安全层原理的讲述。尽管这部分内容相对较难，但如果前面你已经阅读过并理解了认证、授权、凭证、保密的内容，而又对SSL/TLS本身没有什么了解的话，那这一节可能会是最容易理解的讲述传输安全层工作原理的方式。笔者将从“假设传输层安全得不到保障，攻击者如何摧毁之前认证、授权、凭证、保密中所提到的种种安全机制”为具体场景来讲解传输层安全所面临的问题和它的解决方案。</p> <h3 id="摘要、加密与签名">摘要、加密与签名</h3> <p>我们从JWT令牌的一小段“题外话”来引出整套现代加密通讯体系，以便于阐述哈希摘要、对称/非对称加密的特点与局限。我们知道，JWT中携带信息的价值来自于它是被签名的、不可篡改的信息。这一点之前介绍到：</p> <blockquote><p>签名的意义在于确保负载中的信息是可信的、没有被篡改的，也没有在传输过程中丢失。因为被签名的内容哪怕发生了一个字节的变动，也会导致整个签名发生显著变化。此外，由于这件事情只能由认证/授权服务器完成（只有它知道Secret），任何人都无法在篡改后重新计算出合法的签名值，所以服务端才能够完全信任客户端传上来的JWT中的负载信息。</p></blockquote> <p>我们来深入分析一下，“签名”具体是如何让负载中的信息变得“不可篡改”的。以默认的SHA256哈希算法为例，进行签名，相当于进行如下计算过程：</p> <div class="language-java extra-class"><pre class="language-java"><code>signature <span class="token operator">=</span> <span class="token function">SHA256</span><span class="token punctuation">(</span><span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>header<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">&quot;.&quot;</span> <span class="token operator">+</span> <span class="token function">base64UrlEncode</span><span class="token punctuation">(</span>payload<span class="token punctuation">)</span> <span class="token punctuation">,</span> secret<span class="token punctuation">)</span>
</code></pre></div><p>理想的哈希算法通常都会具备两个特性：一是<strong>易变性</strong>，这是指算法的输入发生了任何一点变动，都会导致<a href="https://zh.wikipedia.org/wiki/%E9%9B%AA%E5%B4%A9%E6%95%88%E5%BA%94" target="_blank" rel="noopener noreferrer">雪崩效应<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Avalanche Effect），使得输出结果发生发生极大的变化。这个特性常被用来做校验，譬如互联网上下载大文件，常会附有一个哈希校验码，以确保下载下来的文件没有因网络或其他原因与原文件产生哪怕一个字节的偏差。二是<strong>不可逆性</strong>，这是指算法根据输入计算输出结果耗费的算力资源极小，但根据输出结果反过来推算原本的输入，耗费的算力就极大。一个经常被人们用来讲解不可逆性的例子是<a href="https://zh.wikipedia.org/wiki/%E6%95%B4%E6%95%B0%E5%88%86%E8%A7%A3" target="_blank" rel="noopener noreferrer">大数分解<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，我们可以轻而易举的地（<a href="https://www.reddit.com/r/math/comments/b5aiz1/harvey_and_van_der_hoeven_claim_to_have_found_an/?utm_medium=android_app&amp;utm_source=share" target="_blank" rel="noopener noreferrer">以O(nlogn)的复杂度<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）计算出两个大素数的乘积：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token number">97667323933</span> <span class="token operator">*</span> <span class="token number">128764321253</span> <span class="token operator">=</span> <span class="token number">12576066674829627448049</span>
</code></pre></div><p>根据<a href="https://zh.wikipedia.org/wiki/%E7%AE%97%E6%9C%AF%E5%9F%BA%E6%9C%AC%E5%AE%9A%E7%90%86" target="_blank" rel="noopener noreferrer">算术基本定理<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，质因数的分解形式是唯一的，且前面笔者所举例的运算因子已经都是素数，所以12576066674829627448049的分解形式只有唯一的上面所示的一种答案，但是如何对大数进行因数分解，迄今没有找到多项式时间的解法（24位十进制数的因数分解完全在现代计算机的暴力处理能力范围内，这里只是举例。但目前很多计算机科学家都相信大数分解问题就是一种<a href="https://zh.wikipedia.org/wiki/P/NP%E9%97%AE%E9%A2%98" target="_blank" rel="noopener noreferrer">P!=NP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的证例，尽管也并没有人能证明它一定不存在多项式时间的解法）。不可逆性常被人用来做数字签名，利用的就是如果你知道密钥，很容易通过明文算出签名值，但知道明文和签名值，几乎不可能逆推出密钥，这就实现了签名易于验证，难以破解的特点。</p> <p>必须注意，签名“易于验证、难以破解”是建立在密钥不会泄漏，也不会被篡改的基础上的。当授权服务器与资源服务器是同一个服务时，JWT运作不会遭遇什么风险。而当授权服务器与资源服务器并不是同一个，他们之间就涉及到资源服务其如何验证的问题，无论是资源服务器对每个收到的令牌都请求授权服务器验证一下，还是资源服务器自己也拿到密钥来自行验证令牌真伪都是不可行的。这种情况的解决方案前面讨论中已提到过：</p> <blockquote><p>在多方系统、授权服务与资源服务分离的实际应用中，通常会采用非对称加密算法（典型如RSA）来进行签名，这时候除了授权服务端持有的可以用于签名的私钥外，还会对其他服务器公开一个公钥，公钥不会用来签名，但是能被其他服务用于验证签名是否由私钥所签发的。这样其他服务器也能不依赖授权服务器独立判断JWT令牌中的信息的真伪。</p></blockquote> <p>非对称加密就是加密和解密使用的是不同的密钥的算法，那自然对称加密就是指加密是指加密和解密是一样的密钥的算法。不知道上面看这段话的时候，你心中是否会想“这里写JWT通常会采用非对称加密算法，那改用对称加密行不行呢？”之类的疑问。答案是除非有其他传递或者动态协商密钥的途径，否则这个场景中对称加密是不可行的，因为对称加密只有一个密钥，授权和资源服务不在同一台服务器的话，如何将这个密钥传送给资源服务器？再加密一次传送的话就成了“<a href="https://zh.wikipedia.org/wiki/%E5%85%88%E6%9C%89%E9%B8%A1%E8%BF%98%E6%98%AF%E5%85%88%E6%9C%89%E8%9B%8B" target="_blank" rel="noopener noreferrer">蛋鸡悖论<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>”了。</p> <p>事实上，在分布式环境中，真正能够用来签名的，通常都只有非对称加密算法。在它的密钥对中，其中一个密钥是对外公开的，所有人都可以获取到， 称为公钥，另外一个密钥是不公开的称为私钥。这两个密钥谁加密、谁解密构成了两种不同的用途：</p> <ol><li>公钥加密，私钥解密，这种就是<strong>加密</strong>，用于向公钥所有者发布信息，这个信息可能被他人篡改，但是无法被他人获得。如果甲想给乙发一个安全的保密的数据，那么应该甲乙各自有一个私钥，甲先用乙的公钥加密这段数据，再用自己的私钥加密这段加密后的数据。最后再发给乙，这样确保了内容即不会被读取，也不会被篡改。</li> <li>私钥加密，公钥解密，这种就是<strong>签名</strong>，用于让所有公钥所有者验证私钥所有者的身份并且用来防止私钥所有者发布的内容被篡改。但是不用来保证内容不被他人获得。</li></ol> <p>看到这里，可能有人在想只用“非对称加密”行不行？为什么还需要对称加密？答案是非对称加密算法对加密内容的长度有限制，不能超过公钥长度。譬如说现在常用的公钥是长度是2048 bits，意味着明文不能超过256 bytes。此外，由于对称加密的设计难度相对较小，其加密的效率一般远高于非对称加密，这决定了在大数据量的加密数据传输中，通常是两种加密算法结合使用的，用非对称加密来传递密钥，收到密钥后用对称加密来加密内容。</p> <p>下表把前面涉及到的三种算法放到一块，列举了它们的主要特征、用途和局限性：</p> <table><thead><tr><th><div style="width:80px;">类型</div></th> <th>特点</th> <th>常见实现</th> <th>主要用途</th> <th>主要局限</th></tr></thead> <tbody><tr><td>哈希摘要</td> <td>不可逆，即不能解密，所以并不是加密算法，只是一些场景把它当作加密算法使用<br>易变性，输入发生1Bit变动，就可能导致输出结果50%的内容发生改变。<br>无论输入长度多少，输出长度固定（2的N次幂）</td> <td>MD2/4/5/6、SHA0/1/256/512</td> <td>摘要</td> <td>无法解密</td></tr> <tr><td>对称加密</td> <td>加密是指加密和解密是一样的密钥<br>设计难度相对较小，执行速度相对较块<br>加密明文长度不受限制</td> <td>DES、AES、RC4、IDEA</td> <td>加密</td> <td>要解决如何把密钥安全地传递给解密者</td></tr> <tr><td>非对称加密</td> <td>加密和解密使用的是不同的密钥<br>明文长度不能超过公钥长度</td> <td>RSA、BCDSA、ElGamal</td> <td>签名、传递密钥</td> <td>加密明文长度受限</td></tr></tbody></table> <p>现在我们再回到多方系统如何验证令牌的问题中来。嗯？有了非对称加密，公钥可以不需要加密地公开了，那问题难道还没有解决了吗？并没有，还存在一个明显的漏洞，公钥虽然是公开的，但如何保证要获取公钥的资源服务，拿到的公钥就是授权服务所希望它拿到的呢？如果公钥在网络传输过程中，获取公钥的这一步被攻击者截获并篡改了，返回了攻击者自己提供的公钥，那以后攻击者就可以用自己的私钥签名，让资源服务器无条件信任自己的所有动作了。这里公钥显然也无法再用加密来传输，否则也是一个蛋鸡问题。</p> <h3 id="数字证书">数字证书</h3> <p>当我们无法以“签名”的手段来达成信任时，就只能求助于其他途径。不妨想想真实的世界中，我们是如何达成信任的，其实不外乎以下两种：</p> <ul><li><strong>基于共同私密信息的信任</strong><br>
譬如某个陌生号码找你，说是你的老同学，生病了要找你借钱。你能够信任他得方式是向对方询问一些你们两个应该知道，且只有你们两个知道的私密信息，如果对方能够回答上来，他有可能真的是你的老同学。</li> <li><strong>基于权威公证人的信任</strong><br>如果有个陌生人找你，说他是警察，让你把存款转到他们的安全账号上。你能够信任他的方式是找到公安局，如果公安局担保他确实是个警察，那他有可能真的是警察。</li></ul> <p>回到网络世界中，我们并不能假设授权服务器和资源服务器是互相认识的，所以通常不太会采用第一种方式，而第二种就是目前标准的保证公钥可信分发的标准，这个标准一个名字：<a href="https://zh.wikipedia.org/wiki/%E5%85%AC%E9%96%8B%E9%87%91%E9%91%B0%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD" target="_blank" rel="noopener noreferrer">公开密钥基础设施<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Public Key Infrastructure，PKI）。</p> <div class="quote"><p class="title">公开密钥基础设施（Public Key Infrastructure，PKI）</p><p>又称公开密钥基础架构、公钥基础建设、公钥基础设施、公开密码匙基础建设或公钥基础架构，是一组由硬件、软件、参与者、管理政策与流程组成的基础架构，其目的在于创造、管理、分配、使用、存储以及撤销数字证书。</p> <p>密码学上，公开密钥基础建设借着数字证书认证中心（Certificate Authority，CA）将用户的个人身份跟公开密钥链接在一起。对每个证书中心用户的身份必须是唯一的。链接关系通过注册和发布过程创建，取决于担保级别，链接关系可能由CA的各种软件或在人为监督下完成。PKI的确定链接关系的这一角色称为注册管理中心（Registration Authority，RA）。RA确保公开密钥和个人身份链接，可以防抵赖。</p></div><p>我们不纠缠于PKI概念上的内容，只要知道里面定义了数字证书认证中心便相当于前面例子中“权威公证人”的角色，负责发放和管理数字证书的权威机构（你也可以签发证书，不权威罢了），它作为受信任的第三方，承担公钥体系中公钥的合法性检验的责任。可是，这里和现实世界仍然有一些区别，现实世界你去找的公安局，那大楼不大可能是剧场布景冒认的；而网络世界，在假设所有网络传输都有可能被截获、冒认的前提下，“去CA中心进行认证”本身也是一种网络操作，这与之前的“去获取去公钥”本质上不是没什么差别吗？其实还是有差别的，公钥成千上万不可数，而权威的CA中心则应是可数的，“可数的”意味着可以不通过网络，而在浏览器、操作系统出厂时预置好，或者在专门安装（如银行的证书），下图为我机器上的现存的根证书。</p> <div class="custom-block center"><p><img src="/assets/img/sshot-ca.7b731563.png" alt="">
Windows系统的CA证书</p></div> <p>到这里终于出现了一个这节的关键词之一：证书（Certificate），证书是权威CA中心对特定公钥信息的一层公证载体，由于客户的机器上已经预置了这些权威CA中心本身的证书（称为根证书），使得我们能够在不依靠网络的前提下，使用里面的公钥信息对其所签发的证书中的签名进行确认。到此终于打破了鸡生蛋、蛋生鸡的循环，使得整套数字签名体系有了逻辑基础。</p> <p>PKI中采用的证书格式是<a href="https://zh.wikipedia.org/wiki/X.509" target="_blank" rel="noopener noreferrer">X.509标准格式<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它定义了证书中应该包含哪些信息，并描述了这些信息是如何编码的，里面最关键的就是认证机构的数字签名和公钥信息两项内容。一个证书具体包含以下内容：</p> <ol><li><strong>版本号</strong>（Version）：指出该证书使用了哪种版本的X.509标准（版本1、版本2或是版本3），版本号会影响证书中的一些特定信息，目前的版本为3。</li> <li><strong>序列号</strong>（Serial Number）： 标识证书的唯一整数，由证书颁发者分配的本证书的唯一标识符。</li> <li><strong>签名算法标识符</strong>： 用于签证书的算法标识，由对象标识符加上相关的参数组成，用于说明本证书所用的数字签名算法。例如，SHA1和RSA的对象标识符就用来说明该数字签名是利用RSA对SHA1杂凑加密。</li> <li><strong>认证机构的数字签名</strong>：这是使用证书发布者私钥生成的签名，以确保这个证书在发放之后没有被撰改过。</li> <li><strong>认证机构</strong>： 证书颁发者的可识别名，是签发该证书的实体唯一的CA的<a href="https://zh.wikipedia.org/wiki/X.500" target="_blank" rel="noopener noreferrer">X.500<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>名字。使用该证书意味着信任签发证书的实体（注意：在某些情况下，比如根或顶级CA证书，发布者自己签发证书）。</li> <li><strong>有效期限</strong>（Validity）： 证书起始日期和时间以及终止日期和时间；指明证书在这两个时间内有效。</li> <li><strong>主题信息</strong>（Subject）：证书持有人唯一的标识符（Distinguished Name）这个名字在 互联网上应该是唯一的。</li> <li><strong>公钥信息</strong>（Public-Key）： 包括证书持有人的公钥、算法(指明密钥属于哪种密码系统)的标识符和其他相关的密钥参数。</li> <li><strong>颁发者唯一标识符</strong>（Issuer）：标识符—证书颁发者的唯一标识符，仅在版本2和版本3中有要求，属于可选项。</li></ol> <h3 id="传输安全层">传输安全层</h3> <p>尽管到此为止，数字签名的安全性已经可以自洽了，但相信你也感受到了这套信任链的繁琐，如果从确定加密算法、生成密钥、公钥分发、CA认证、核验公钥、签名、验证签名这些步骤都要由用户来承担的话，这样意义的“安全”估计只能一直是存于实验室中的阳春白雪。如何把这一套繁琐的技术体系自动化地应用于无处不在的网络通讯之中，是这一节要讨论的话题。</p> <p>在计算机科学里，隔离复杂性的常用手段之一就是分层，在网络中更是如此，OSI模型、TCP/IP模型将网络从物理特性（比特流）开始，逐层封装隔离，到了HTTP协议这种面向应用的协议里，就已经不会去关心网卡/交换机如何处理数据帧、MAC地址；不会去关心ARP如何做地址转换；不会去关心IP寻址、TCP传输等等；那要在网络中让用户无感知地、自动地安全通讯，最合理的做法就是在传输层之上、应用层之下加入一层安全层来实现，这样对上层原本基于HTTP的Web应用来说，几乎可以是毫无感知的。而构建传输安全层这件事情，可以说是和万维网的历史一样长，早在1994年，就已经有公司开始着手去尝试了，这里先简单回顾这将近30年来的进展：</p> <ul><li>1994年，网景（Netscape）公司开发了SSL协议（Secure Sockets Layer）的1.0版，这是构建传输安全层的起源，但是SSL 1.0并未正式对外发布。</li> <li>1995年，Netscape把SSL升级到2.0版，正式对外发布，但是刚刚发布不久就被发现有严重漏洞，所以并未大规模使用。</li> <li>1996年，修补好漏洞的SSL 3.0对外发布，这个版本得到了广泛的应用，成为Web网络安全层的事实标准。</li> <li>1999年，互联网标准化组织接替Netscape，将SSL改名TLS（Transport Layer Security）后推进为国际标准，第一个正式的版本是<a href="https://tools.ietf.org/html/rfc2246" target="_blank" rel="noopener noreferrer">RFC 2246<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>定义的TLS 1.0。这个版本的TLS生存时间极长，直至我写下这段文字的2020年3月，主流浏览器（Chrome、Firefox、IE、Safari）才刚刚共同宣布停止TLS 1.0/1.1的支持。而讽刺的是，由于停止后许多政府网站被无法被浏览，此时又正值新冠病毒（COVID-19）爆发期，Firefox紧急<a href="https://www.mozilla.org/en-US/firefox/74.0/releasenotes/" target="_blank" rel="noopener noreferrer">发布公告<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>宣布撤回该改动，TLS 1.0的生命还在顽强延续。</li> <li>2006年，TLS的第一个升级版1.1发布（<a href="https://tools.ietf.org/html/rfc4346" target="_blank" rel="noopener noreferrer">RFC 4346<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），但却沦为了被遗忘的孩子，很少人使用TLS 1.1，甚至到了因此该版本没有已知的协议漏洞被提出的程度。</li> <li>2008年，TLS 1.1发布2年之后，TLS 1.2标准发布（<a href="https://tools.ietf.org/html/rfc5246" target="_blank" rel="noopener noreferrer">RFC 5246<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），迄今超过90%的互联网HTTPS流量是由TLS 1.2所支持的，现在仍在使用的浏览器几乎都完美支持了该协议。</li> <li>2018年，最新的TLS 1.3（<a href="https://tools.ietf.org/html/rfc8446" target="_blank" rel="noopener noreferrer">RFC 8446<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）发布，比起前面版本相对温和的升级，TLS 1.3做了出了一些激烈的改动，包括修改了从1.0起一直没有大变化的2轮4次（2-RTT）握手，首次连接仅需1轮（1-RTT）即可完成，在连接复用时甚至将TLS 1.2原本的1-RTT下降到了0-RTT，显著提升了访问速度。</li></ul> <p>下面笔者将以TLS 1.2为例，介绍传输安全层是如何保障所有信息都是第三方无法窃听（加密传输）、无法篡改（一旦篡改通讯算法会立刻发现）、无法冒充（证书验证身份）的。TLS 1.2在传输之前的握手过程一共需要进行上下2轮、4次信息发送，时序如下所示：</p> <div class="mermaid" style="margin-bottom:0px;">
sequenceDiagram
	客户端 -&gt;&gt; 服务器: 客户端请求：Client Hello
	服务器 --&gt;&gt; 客户端: 服务器回应：Server Hello
	客户端 -&gt;&gt; 服务器: 客户端确认：Client Handshake Finished
	服务器 --&gt;&gt; 客户端: 服务端确认：Server Handshake Finished
</div> <p>在介绍这四次握手具体会做什么之前，先推荐一个制作很用心的网站（<a href="https://tls.ulfheim.net/" target="_blank" rel="noopener noreferrer">https://tls.ulfheim.net/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），上面以网页的方式详细解释了每一次握手过程中所做的事情、发送的数据、收到的响应等内容。然后，让我们开始一段相对要枯燥困难一些的握手过程：</p> <ol><li><p><strong>客户端请求</strong>：Client Hello<br>
客户端（一般就是浏览器了）向服务器请求进行加密通讯，在这个请求里面，它会以<strong>明文</strong>的形式，向服务端提供以下信息：</p> <ul><li>支持的协议版本，譬如TLS 1.2。但是要注意，1.0-3.0分别代表SSL1.0-3.0，TLS1.0则是3.1，一直到TLS1.3的3.4。</li> <li>一个客户端生成的32 bytes随机数，这个随机数将稍后用于产生加密的密钥。</li> <li>一个SessionID（可选），不要和前面Cookie-Session那套混淆了，这个SessionID是只链接的SessionID，是为了TLS的链接复用。</li> <li>一系列支持的<a href="https://zh.wikipedia.org/wiki/%E5%AF%86%E7%A0%81%E5%A5%97%E4%BB%B6" target="_blank" rel="noopener noreferrer">密码学算法套件<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，它应该是一组算法的组合，例如TLS_RSA_WITH_AES_128_GCM_SHA256，代表着密钥交换算法是RSA，加密算法是AES128-GCM，消息认证码算法是SHA256</li> <li>一系列支持的压缩算法。</li> <li>其他可扩展的信息，为了保证协议的稳定，后续对协议的功能扩展大多都添加到这个变长结构中。譬如TLS 1.0中由于发送的数据并不包含服务器的域名地址，导致了一台服务器只能安装一张数字证书，这对虚拟主机来说就很不方便，所以TLS 1.1起就增加了名为“Server Name”的扩展，以便一台服务器给不同的站点安装不同的证书。</li></ul></li> <li><p><strong>服务器回应</strong>：Server Hello<br>
服务端收到客户单的通讯请求后，如果客户端支持的协议版本、加密算法组合在服务端中能找到一致的，将向客户端发出回应。如果不行，将会返回一个握手失败的警告提示。这次回应同样是明文的，包括以下信息：</p> <ul><li>服务端确认使用的协议版本。</li> <li>第二个32 bytes的随机数，稍后用于产生加密的密钥。</li> <li>一个SessionID，以后链接复用可以减少一轮握手。</li> <li>服务端选定的密码学算法套件。</li> <li>服务端选定的压缩方法。</li> <li>其他可扩展的信息。</li> <li>如果协商出的加密算法组合是依赖证书认证的，服务端要发送出自己的X.509证书，而证书中的公钥是什么，也必须根据协商的加密算法组合来决定。</li> <li>密钥协商消息，这部对于不同密码学套件有不同的价值，譬如对于ECDH + anon这样得密钥协商算法组合（基于椭圆曲线的<a href="https://zh.wikipedia.org/wiki/%E6%A9%A2%E5%9C%93%E6%9B%B2%E7%B7%9A%E8%BF%AA%E8%8F%B2-%E8%B5%AB%E7%88%BE%E6%9B%BC%E9%87%91%E9%91%B0%E4%BA%A4%E6%8F%9B" target="_blank" rel="noopener noreferrer">ECDH算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>可以在双方通讯都公开的情况下协商出一组只有通讯双方知道的密钥）就不依赖证书中的公钥，而是通过Server Key Exchange消息协商出密钥。</li></ul></li> <li><p><strong>客户端确认</strong>：Client Handshake Finished<br>
由于密码学套件的组合复杂多样，这里仅以RSA算法为密钥交换算法为例介绍后续过程。客户端收到服务器应答后，先要验证服务器证书。如果证书不是可信机构颁布、或者证书中信息存在问题（域名与实际域名不一致、或者证书已经过期、或通过<a href="https://zh.wikipedia.org/wiki/%E5%9C%A8%E7%BA%BF%E8%AF%81%E4%B9%A6%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">在线证书状态协议<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>得知证书已被吊销，等等），都会向访问者显示一个“证书不可信任”的警告，由其选择是否还要继续通信。如果证书没有问题，客户端就会从证书中取出服务器的公钥，并向服务器发送以下信息：</p> <ul><li>客户端证书（可选）。部分服务端并不是面向全公众，只对特定的客户端提供服务，此时客户端需要发送它自身的证书，如果不发送，或者验证不通过，服务端可执行决定是否要继续握手，或者返回一个握手失败的信息。</li> <li>第三个32 bytes的随机数，这个随机数不再是明文发送，而是以服务端传过来的公钥加密的，它被称为PreMasterSecret，将与前两次发送的随机数一起，根据<a href="https://tls.ulfheim.net/files/curve25519-mult.c" target="_blank" rel="noopener noreferrer">特定算法<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>计算出48 bytes的MasterSecret ，此即为后续内容传输时的对称加密算法所采用的私钥。</li> <li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li> <li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时也是前面发送的所有内容的哈希值，用来供服务器校验。</li></ul></li> <li><p><strong>服务端确认</strong>：Server Handshake Finished<br>
服务端向客户端回应最后的确认通知，包括以下信息：</p> <ul><li>编码改变通知，表示随后的信息都将用双方商定的加密方法和密钥发送。</li> <li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时也是前面发送的所有内容的哈希值，用来供客户端校验。</li></ul></li></ol> <p>至此，整个握手阶段全部结束，一个安全的链接已经建立，每一个链接建立时，客户端和服务端均通过上面的握手过程协商出了一个只有双方才知道的随机产生的密钥，以及后面传输过程中要采用的对称加密算法（如例子中的AES128），此后该链接的通讯将使用此密钥和加密算法进行加、解密。这种处理方式对上层协议的功能上完全没有影响（性能上当然有影响），建立在这层安全传输层之上的HTTP协议，就被称为“HTTP Over SSL/TLS”，即大家熟知的HTTPS。</p> <p>从上面握手协商的过程中我们还可以得知，HTTPS同样并非是离散的二元选项，不是只有“启用了HTTPS”和“未启用HTTPS”的差别，采用不同的协议版本、不同的密码学套件、证书是否有效、服务端/客户端对面对无效证书时的处理策略如何都导致了不同HTTPS站点的安全强度的不同。你可以使用<a href="https://myssl.com" target="_blank" rel="noopener noreferrer">亚洲诚信<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的诊断服务查看以下几个网站的安全评分，以对安全强度有更加量化直观的理解：</p> <ul><li>亚洲诚信：<a href="https://myssl.com/myssl.com" target="_blank" rel="noopener noreferrer">https://myssl.com/myssl.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>腾讯网：<a href="https://myssl.com/www.qq.com" target="_blank" rel="noopener noreferrer">https://myssl.com/www.qq.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>本站：<a href="https://myssl.com/icyfenix.cn" target="_blank" rel="noopener noreferrer">https://myssl.com/icyfenix.cn<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>趣店：<a href="https://myssl.com/www.quqianbao.com" target="_blank" rel="noopener noreferrer">https://myssl.com/www.quqianbao.com<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <h2 id="验证">验证 <span class="badge tip" style="vertical-align:top;" data-v-15b7b770>已完成</span></h2> <div class="custom-block tip"><p class="custom-block-title">验证（Verification）</p> <p>系统如何确保提交到每项服务中的数据是合乎规则的，不会对系统稳定性、数据一致性、正确性产生风险？</p></div> <p>一般认为，数据验证不归属在安全这个话题中，但请相信我，从数量来讲，数据验证不严谨而导致的安全问题比其他安全攻击导致的要多得多；而风险上讲，由数据质量导致的问题，风险有高有低，真遇到高风险的数据问题，导致的损失不一定比被拖库什么来的小。</p> <p>不过，相比起其他富有挑战性的安全措施，防御与攻击两者缠斗的精彩，数学、心理、社会工程和计算机等跨学科知识的结合运用，数据验证倒确实是不可否认地有些无聊枯燥的，这是一项非常常见的工作，在日常的开发中贯穿于代码的各个层次，每个程序员都肯定写过。以架构者的视角，这种常见的代码反而是迫切需要被架构约束的，缺失的校验影响数据质量，过度的校验不会使得系统更加健壮，某种意义上反而是垃圾代码，甚至有副作用。来看看下面这个段子：</p> <div class="language- extra-class"><pre class="language-text"><code>前  端： 提交一份用户数据（姓名:某, 性别:男, 爱好:女, 签名:xxx, 手机:xxx, 邮箱:null）
控制器： 发现邮箱是空的，抛ValidationException(&quot;邮箱没填&quot;)
前  端： 已修改，重新提交
安  全： 发送验证码时发现手机号少一位，抛RemoteInvokeException(&quot;无法发送验证码&quot;)
前  端： 已修改，重新提交
服务层： 邮箱怎么有重复啊，抛BusinessRuntimeException(&quot;不允许开小号&quot;)
前  端： 已修改，重新提交
持久层： 签名字段超长了插不进去，抛SQLException(&quot;插入数据库失败，SQL：xxx&quot;)
…… ……
前  端： 你们这些坑管挖不管埋的后端，各种异常都往前抛！
用  户： 这系统牙膏厂生产的？
</code></pre></div><p>最基础的数据问题可以在前端做表单校验来处理，但后端验证肯定是要做的，上面的段子看完了想一想，服务端应该在哪一层去做校验？可能会有这样的答案：</p> <ul><li>在Controller层做，在Service层不做。理由是从Service开始会有同级重用，出现ServiceA.foo(params)调用ServiceB.bar(params)时，相当于对params重复校验了两次。</li> <li>在Service层做，在Controller层不做。理由是无业务含义的格式校验已在前端表单验证处理过，有业务含义的校验，放在Controller层无论如何不合适。</li> <li>在Controller、Service层各做各的。Controller做格式校验，Service层做业务校验，就是上面那段子中的行为。</li> <li>还有其他一些意见，譬如还有提在持久层做校验，理由是这是最终入口，把守好写入数据库的质量最重要。</li></ul> <p>上述的讨论大概是不会有统一的正确结论，但是在Java里确实是有验证的标准做法，提倡的是把校验行为从分层中剥离出来，不是在哪一层做，而是在Bean上做。即Java Bean Validation。从2009年的<a href="https://beanvalidation.org/1.0/spec/" target="_blank" rel="noopener noreferrer">JSR 303<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的1.0，到2013年的<a href="https://jcp.org/en/jsr/detail?id=349" target="_blank" rel="noopener noreferrer">JSR 349<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>更新的1.1，到目前最新的2017年发布的<a href="https://beanvalidation.org/2.0/" target="_blank" rel="noopener noreferrer">JSR 380<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>，定义了Bean验证的全套规范。单独将验证提取、封装，可以获得不少好处：</p> <ul><li>对于无业务含义的格式验证，可以做到预置。</li> <li>对于有业务含义的业务验证，可以做到重用。一个Bean适用于多个方法是非常常见的。</li> <li>利于集中管理，譬如统一认证的异常体系，统一做国际化、统一给客户端的返回格式等等。</li> <li>避免对输入数据的防御污染到业务代码，如果你的代码里面如果很多下面这样的条件判断，应该考虑重构<div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">// 一些已执行的逻辑</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>someParam <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeExcetpion</span><span class="token punctuation">(</span><span class="token string">&quot;客官不可以！&quot;</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li>利于多个校验器统一执行，统一返回校验结果，避免用户踩地雷、挤牙膏式的试错体验。</li></ul> <p>其实，据我了解，国内的项目使用Bean Validation的还是不少的，但多数都只使用到它的Built-In Constraint，即下面这堆注解（含义我就不写了，用处基本上看类名就能明白）：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token annotation punctuation">@Null</span>、<span class="token annotation punctuation">@NotNull</span>、<span class="token annotation punctuation">@AssertTrue</span>、<span class="token annotation punctuation">@AssertFalse</span>、<span class="token annotation punctuation">@Min</span>、<span class="token annotation punctuation">@Max</span>、<span class="token annotation punctuation">@DecimalMin</span>、<span class="token annotation punctuation">@DecimalMax</span>、<span class="token annotation punctuation">@Negative</span>、<span class="token annotation punctuation">@NegativeOrZero</span>、<span class="token annotation punctuation">@Positive</span>、<span class="token annotation punctuation">@PositiveOrZeor</span>、<span class="token annotation punctuation">@Szie</span>、<span class="token annotation punctuation">@Digits</span>、<span class="token annotation punctuation">@Pass</span>、<span class="token annotation punctuation">@PassOrPresent</span>、<span class="token annotation punctuation">@Future</span>、<span class="token annotation punctuation">@FutureOrPresent</span>、<span class="token annotation punctuation">@Pattern</span>、<span class="token annotation punctuation">@NotEmpty</span>、<span class="token annotation punctuation">@NotBlank</span>、<span class="token annotation punctuation">@Email</span>
</code></pre></div><p>一般实现会采用Hibernate Validator，另外一个非主流选择是Apache BVal，它们都扩展了自己的私有注解。其中有一些注解，像@Email、@NotEmpty、@NotBlank，从以前Hibernate Validator私有注解，随着版本升级转正成为标准。</p> <p>但是其中多数项目对Bean Validation的使用就到此为止了，带业务含义的代码都还是习惯写到方法体内，导致完全没法管理。其实这部分带有复杂逻辑的校验，才是最需要约束的，更加应该借助Bean Validation来完成。以Fenix‘s Bookstore的在用户资源上的两个方法为例：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
* 创建新的用户
*/</span>
<span class="token annotation punctuation">@POST</span>
<span class="token keyword">public</span> <span class="token class-name">Response</span> <span class="token function">createUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Valid</span> <span class="token annotation punctuation">@UniqueAccount</span> <span class="token class-name">Account</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token class-name">CommonResponse</span><span class="token punctuation">.</span><span class="token function">op</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> service<span class="token punctuation">.</span><span class="token function">createAccount</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">/**
* 更新用户信息
*/</span>
<span class="token annotation punctuation">@PUT</span>
<span class="token annotation punctuation">@CacheEvict</span><span class="token punctuation">(</span>key <span class="token operator">=</span> <span class="token string">&quot;#user.username&quot;</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token class-name">Response</span> <span class="token function">updateUser</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Valid</span> <span class="token annotation punctuation">@AuthenticatedAccount</span> <span class="token annotation punctuation">@NotConflictAccount</span> <span class="token class-name">Account</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>
	<span class="token keyword">return</span> <span class="token class-name">CommonResponse</span><span class="token punctuation">.</span><span class="token function">op</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> service<span class="token punctuation">.</span><span class="token function">updateAccount</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意其中的三个自定义校验注解，它们的含义分别是：</p> <ul><li>@UniqueAccount：传入的用户对象必须是唯一的，不与数据库中任何已有用户的名称、手机、邮箱产生重复。</li> <li>@AuthenticatedAccount：传入的用户对象必须与当前登陆的用户一致。</li> <li>@NotConflictAccount：传入的用户对象中的信息与其他用户是无冲突的，譬如将一个注册用户的邮箱，修改成与另外一个已存在的注册用户一致的值，这便是冲突。</li></ul> <p>这里的需求很容易想明白，注册新用户时，应约束不与任何已有用户的关键信息重复；而修改自己的信息时，只能与自己的信息重复，而且只能修改当前登陆用户的信息。这些约束规则不仅仅为这两个方法服务，它们可能会在用户资源中的其他入口被使用到，甚至在其他分层的代码中被使用到。下面是这三个自定义注解对应校验器的实现类：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">AuthenticatedAccountValidator</span> <span class="token keyword">extends</span> <span class="token class-name">AccountValidation</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">AuthenticatedAccount</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">AuthenticatedAccount</span> constraintAnnotation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        predicate <span class="token operator">=</span> c <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">AuthenticAccount</span> loginUser <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">AuthenticAccount</span><span class="token punctuation">)</span> <span class="token class-name">SecurityContextHolder</span><span class="token punctuation">.</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAuthentication</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPrincipal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>loginUser<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">UniqueAccountValidator</span> <span class="token keyword">extends</span> <span class="token class-name">AccountValidation</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">UniqueAccount</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">UniqueAccount</span> constraintAnnotation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        predicate <span class="token operator">=</span> c <span class="token operator">-&gt;</span> <span class="token operator">!</span>repository<span class="token punctuation">.</span><span class="token function">existsByUsernameOrEmailOrTelephone</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">getTelephone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">NotConflictAccountValidator</span> <span class="token keyword">extends</span> <span class="token class-name">AccountValidation</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">NotConflictAccount</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>
    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">initialize</span><span class="token punctuation">(</span><span class="token class-name">NotConflictAccount</span> constraintAnnotation<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        predicate <span class="token operator">=</span> c <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>
            <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Account</span><span class="token punctuation">&gt;</span></span> collection <span class="token operator">=</span> repository<span class="token punctuation">.</span><span class="token function">findByUsernameOrEmailOrTelephone</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">getTelephone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token comment">// 将用户名、邮件、电话改成与现有完全不重复的，或者只与自己重复的，就不算冲突</span>
            <span class="token keyword">return</span> collection<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>collection<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> collection<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这样业务校验便和业务逻辑分离开来，在需要使用时用@Valid注解自动或者通过代码手动触发执行，可根据你们公司的要求，使用于控制器、服务层、持久层等任何层次之中。此外，校验结果不满足时的提示信息，也便于统一处理，如提供默认值、提供国际化支持（这里没做）、提供统一的客户端返回格式（创建一个用于ConstraintViolationException的异常处理器），以及批量执行全部校验避免挤牙膏等诸多好处。下面是预置默认提示信息的例子：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token comment">/**
 * 表示一个用户的信息是无冲突的
 * 
 * “无冲突”是指该用户的敏感信息与其他用户不重合，譬如将一个注册用户的邮箱，修改成与另外一个已存在的注册用户一致的值，这便是冲突
 **/</span>
<span class="token annotation punctuation">@Documented</span>
<span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RUNTIME<span class="token punctuation">)</span>
<span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>FIELD<span class="token punctuation">,</span> METHOD<span class="token punctuation">,</span> PARAMETER<span class="token punctuation">,</span> TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token annotation punctuation">@Constraint</span><span class="token punctuation">(</span>validatedBy <span class="token operator">=</span> <span class="token class-name">AccountValidation</span><span class="token punctuation">.</span><span class="token class-name">NotConflictAccountValidator</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>
<span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">NotConflictAccount</span> <span class="token punctuation">{</span>
    <span class="token class-name">String</span> <span class="token function">message</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">&quot;用户名称、邮箱、手机号码与现存用户产生重复&quot;</span><span class="token punctuation">;</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">groups</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Payload</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">payload</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

</code></pre></div><p>另外一条建议是将不带业务含义的格式校验注解放到类上，将带业务含义的注解放到外面。譬如用户账号实体中的部分代码为：</p> <div class="language-java extra-class"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Account</span> <span class="token keyword">extends</span> <span class="token class-name">BaseEntity</span> <span class="token punctuation">{</span>
	<span class="token annotation punctuation">@NotEmpty</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">&quot;用户不允许为空&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@NotEmpty</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">&quot;用户姓名不允许为空&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> name<span class="token punctuation">;</span>

    <span class="token keyword">private</span> <span class="token class-name">String</span> avatar<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Pattern</span><span class="token punctuation">(</span>regexp <span class="token operator">=</span> <span class="token string">&quot;1\\d{10}&quot;</span><span class="token punctuation">,</span> message <span class="token operator">=</span> <span class="token string">&quot;手机号格式不正确&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> telephone<span class="token punctuation">;</span>

    <span class="token annotation punctuation">@Email</span><span class="token punctuation">(</span>message <span class="token operator">=</span> <span class="token string">&quot;邮箱格式不正确&quot;</span><span class="token punctuation">)</span>
    <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>把校验注解放在类定义中，意味着所有执行校验的时候它们都会被运行（譬如Insert、Update的时候，Hibernate都会自动执行DO上的校验注解）。而不带业务含义的注解运行是不需要其他外部资源（譬如数据库）参与的，这种重复执行通常并无坏处（系统的压力往往不在CPU，闲着也是闲着）。</p> <p>如果真的遇到一些非典型情况，譬如“新增”操作需要执行全部校验规则，“修改”操作中希望不校验某个字段，“删除”操作C中希望改变某一条校验规则，这时候要就要启用分组校验来处理，设计一套“新增”、“修改”、“删除”这样的标识类，置入到校验注解的groups参数中。</p> <h2 id="漏洞利用">漏洞利用 <span class="badge warning" style="vertical-align:top;" data-v-15b7b770>编写中</span></h2> <div class="custom-block tip"><p class="custom-block-title">漏洞利用（Exploit）</p> <p>系统如何避免在基础设施和应用程序中出现弱点，被攻击者利用？</p></div></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/fenixsoft/awesome-fenix/edit/master/architect-perspective/general-architecture/system-security.md" target="_blank" rel="noopener noreferrer">在GitHub中编辑</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">总字数:</span> <span class="words">30,446</span> <span class="prefix">字　</span> <span class="prefix">最后更新:</span> <span class="time">4/5/2020, 12:03:17 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
    ←
    <a href="/architect-perspective/general-architecture/api-style.html" class="prev">
      服务设计风格
    </a></span> <span class="next"><a href="/architect-perspective/general-architecture/transaction.html">
      事务一致性
    </a>
    →
  </span></p></div> </main></div><div class="global-ui"><div></div><!----></div></div>
    <script src="/assets/js/app.23543073.js" defer></script><script src="/assets/js/2.661f0606.js" defer></script><script src="/assets/js/3.2017d3a0.js" defer></script><script src="/assets/js/9.8542fc4f.js" defer></script><script src="/assets/js/7.7db15abe.js" defer></script>
  </body>
</html>
