<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>√ 服务设计风格 | 软件架构探索：The Fenix Project</title>
    <meta name="description" content="现代软件架构探索">
    <meta name="generator" content="VuePress 1.3.1">
    <link rel="shortcut icon" type="image/x-icon" href="./favicon.ico">
    
    <link rel="preload" href="/assets/css/0.styles.7a3888f9.css" as="style"><link rel="preload" href="/assets/js/app.ebee20fc.js" as="script"><link rel="preload" href="/assets/js/2.d5b46b4e.js" as="script"><link rel="preload" href="/assets/js/9.77c59a10.js" as="script"><link rel="prefetch" href="/assets/js/10.ce357394.js"><link rel="prefetch" href="/assets/js/11.acb01f3a.js"><link rel="prefetch" href="/assets/js/12.64f1f2bf.js"><link rel="prefetch" href="/assets/js/13.a28b7283.js"><link rel="prefetch" href="/assets/js/14.71e5e432.js"><link rel="prefetch" href="/assets/js/15.7276d91f.js"><link rel="prefetch" href="/assets/js/16.4e48a83d.js"><link rel="prefetch" href="/assets/js/17.a99037d3.js"><link rel="prefetch" href="/assets/js/18.77a1763f.js"><link rel="prefetch" href="/assets/js/19.b8bed66d.js"><link rel="prefetch" href="/assets/js/20.c5b006af.js"><link rel="prefetch" href="/assets/js/21.306755cc.js"><link rel="prefetch" href="/assets/js/22.6e9d0f74.js"><link rel="prefetch" href="/assets/js/23.b9595b3d.js"><link rel="prefetch" href="/assets/js/24.d6310162.js"><link rel="prefetch" href="/assets/js/25.e46e0ade.js"><link rel="prefetch" href="/assets/js/26.131aee57.js"><link rel="prefetch" href="/assets/js/27.5ae46bc2.js"><link rel="prefetch" href="/assets/js/28.a417fc21.js"><link rel="prefetch" href="/assets/js/29.081fd8dc.js"><link rel="prefetch" href="/assets/js/3.d26ef381.js"><link rel="prefetch" href="/assets/js/30.daa18b8c.js"><link rel="prefetch" href="/assets/js/31.a2d350b2.js"><link rel="prefetch" href="/assets/js/32.f45790d4.js"><link rel="prefetch" href="/assets/js/33.e96614a4.js"><link rel="prefetch" href="/assets/js/34.f5665896.js"><link rel="prefetch" href="/assets/js/35.04a88f13.js"><link rel="prefetch" href="/assets/js/36.f3874119.js"><link rel="prefetch" href="/assets/js/37.4e2ab706.js"><link rel="prefetch" href="/assets/js/38.a8946723.js"><link rel="prefetch" href="/assets/js/39.5080c2cc.js"><link rel="prefetch" href="/assets/js/4.3de17ccc.js"><link rel="prefetch" href="/assets/js/40.8cd7b2bb.js"><link rel="prefetch" href="/assets/js/41.1af16712.js"><link rel="prefetch" href="/assets/js/42.7cac5357.js"><link rel="prefetch" href="/assets/js/43.435d3454.js"><link rel="prefetch" href="/assets/js/44.ae8b4d63.js"><link rel="prefetch" href="/assets/js/45.765b5d5f.js"><link rel="prefetch" href="/assets/js/46.fcf8af4b.js"><link rel="prefetch" href="/assets/js/47.2f2c8eb4.js"><link rel="prefetch" href="/assets/js/48.98013253.js"><link rel="prefetch" href="/assets/js/49.b43cc968.js"><link rel="prefetch" href="/assets/js/5.797f2502.js"><link rel="prefetch" href="/assets/js/50.6c9f900b.js"><link rel="prefetch" href="/assets/js/51.e394ee79.js"><link rel="prefetch" href="/assets/js/52.0e87bfe5.js"><link rel="prefetch" href="/assets/js/53.d9d03a5b.js"><link rel="prefetch" href="/assets/js/54.86c9c033.js"><link rel="prefetch" href="/assets/js/55.9bf94f5b.js"><link rel="prefetch" href="/assets/js/56.d8468bce.js"><link rel="prefetch" href="/assets/js/57.082d62d8.js"><link rel="prefetch" href="/assets/js/58.e359eed6.js"><link rel="prefetch" href="/assets/js/59.a3904f72.js"><link rel="prefetch" href="/assets/js/6.e07e222e.js"><link rel="prefetch" href="/assets/js/60.de1793b7.js"><link rel="prefetch" href="/assets/js/61.03e6eacf.js"><link rel="prefetch" href="/assets/js/62.197332e8.js"><link rel="prefetch" href="/assets/js/63.c8a2b91f.js"><link rel="prefetch" href="/assets/js/64.48b2e98d.js"><link rel="prefetch" href="/assets/js/65.0502d02f.js"><link rel="prefetch" href="/assets/js/7.681e02a5.js"><link rel="prefetch" href="/assets/js/8.c26cfcf9.js">
    <link rel="stylesheet" href="/assets/css/0.styles.7a3888f9.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/images/logo-color.png" alt="软件架构探索：The Fenix Project" class="logo"> <span class="site-name can-hide">软件架构探索：The Fenix Project</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/fenix-bookstore-frontend" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端工程
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/monolithic_arch_springboot" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：单体架构 SpringBoot
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/microservice_arch_springcloud" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：微服务架构 SpringCloud
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/microservice_arch_kubernetes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：微服务架构 Kubernetes
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/serverless_arch_knative" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：无服务架构 Knative
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="http://bookstore.icyfenix.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  示例
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/board.html" class="nav-link">
  讨论区
</a></div> <a href="https://github.com/fenixsoft/awesome-fenix" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="代码" class="dropdown-title"><span class="title">代码</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/fenix-bookstore-frontend" target="_blank" rel="noopener noreferrer" class="nav-link external">
  前端工程
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/monolithic_arch_springboot" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：单体架构 SpringBoot
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/microservice_arch_springcloud" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：微服务架构 SpringCloud
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/microservice_arch_kubernetes" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：微服务架构 Kubernetes
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li><li class="dropdown-item"><!----> <a href="https://github.com/fenixsoft/serverless_arch_knative" target="_blank" rel="noopener noreferrer" class="nav-link external">
  后端：无服务架构 Knative
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul></div></div><div class="nav-item"><a href="http://bookstore.icyfenix.cn" target="_blank" rel="noopener noreferrer" class="nav-link external">
  示例
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div><div class="nav-item"><a href="/board.html" class="nav-link">
  讨论区
</a></div> <a href="https://github.com/fenixsoft/awesome-fenix" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前言</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/introduction/about-me.html" class="sidebar-link">√ 关于作者</a></li><li><a href="/introduction/about-the-fenix-project.html" class="sidebar-link">√ 什么是“The Fenix Project”？</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>迈向软件架构</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/deployment/development-env-setup/" class="sidebar-heading clickable open"><span>√ 如何开始</span> <span class="arrow down"></span></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/deployment/development-env-setup/fenix-bookstore-frontend.html" class="sidebar-link">√ 前端工程</a></li><li><a href="/deployment/development-env-setup/monolithic_arch_springboot.html" class="sidebar-link">√ 后端工程：SpringBoot</a></li><li><a href="/deployment/development-env-setup/microservice_arch_springcloud.html" class="sidebar-link">后端工程：SpringCloud</a></li><li><a href="/deployment/development-env-setup/microservice_arch_kubernetes.html" class="sidebar-link">后端工程：Kubernetes</a></li><li><a href="/deployment/development-env-setup/serverless_arch_knative.html" class="sidebar-link">后端工程：Knative</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/deployment/deployment-env-setup/" class="sidebar-heading clickable"><span>√ 环境依赖</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/deployment/deployment-env-setup/setup-docker.html" class="sidebar-link">√ 部署Docker CE容器环境</a></li><li><section class="sidebar-group collapsable is-sub-group depth-2"><a href="/deployment/deployment-env-setup/setup-kubernetes" class="sidebar-heading clickable"><span>√ 部署Kubernetes集群</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><a href="/deployment/operation-env-setup" class="sidebar-heading clickable"><span>运维环境</span> <span class="arrow right"></span></a> <!----></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>架构的视角</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><a href="/architect-perspective/general-architecture" class="sidebar-heading clickable router-link-active open"><span>架构的普适问题</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/architect-perspective/general-architecture/api-style.html" class="active sidebar-link">√ 服务设计风格</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/api-style.html#远程服务调用" class="sidebar-link">远程服务调用</a></li><li class="sidebar-sub-header"><a href="/architect-perspective/general-architecture/api-style.html#restful服务" class="sidebar-link">RESTful服务</a></li></ul></li><li><a href="/architect-perspective/general-architecture/system-security.html" class="sidebar-link">√ 安全架构</a></li><li><a href="/architect-perspective/general-architecture/transaction.html" class="sidebar-link">事务</a></li><li><a href="/architect-perspective/general-architecture/constraint.html" class="sidebar-link">可约束性</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><p class="sidebar-heading"><span>技巧与专题</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/architect-perspective/tricks/distributed-transaction.html" class="sidebar-link">分布式与一致性</a></li><li><a href="/architect-perspective/tricks/graalvm-improvement.html" class="sidebar-link">GraalVM：微服务时代的Java</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>演进中的微服务</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/architecture/architect-history.html" class="sidebar-link">服务架构演进史</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/architecture/monolithic-architecture" class="sidebar-heading clickable"><span>单体架构</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/architecture/monolithic-architecture/j2ee-base-arch.html" class="sidebar-link">基于J2EE的单体架构</a></li><li><a href="/architecture/monolithic-architecture/springboot-base-arch.html" class="sidebar-link">基于SpringBoot的单体架构</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/architecture/microservices-architecture" class="sidebar-heading clickable"><span>微服务架构</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/architecture/microservices-architecture/springcloud-base-arch.html" class="sidebar-link">SpringCloud时代的微服务</a></li><li><a href="/architecture/microservices-architecture/kubernetes-base-arch.html" class="sidebar-link">Kubernetes时代的微服务</a></li><li><a href="/architecture/microservices-architecture/servicemesh-lstio-arch.html" class="sidebar-link">后Kubernetes时代的微服务</a></li></ul></section></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/architecture/serverless-architecture" class="sidebar-heading clickable"><span>无服务架构</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/architecture/serverless-architecture/serverless-arch-knative.html" class="sidebar-link">基于Knative的无服务</a></li><li><a href="/architecture/serverless-architecture/serverless-arch-kubeless.html" class="sidebar-link">基于Kubeless的无服务</a></li></ul></section></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>核心技术支撑点</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/technology/service-discovery.html" class="sidebar-link">服务发现</a></li><li><a href="/technology/load-balancing.html" class="sidebar-link">负载均衡</a></li><li><section class="sidebar-group is-sub-group depth-1"><a href="/technology/invokechain-manage" class="sidebar-heading clickable"><span>链路治理</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/technology/invokechain-manage/traffic-control.html" class="sidebar-link">流控</a></li><li><a href="/technology/invokechain-manage/service-downgrade.html" class="sidebar-link">降级</a></li><li><a href="/technology/invokechain-manage/exception-inject.html" class="sidebar-link">异常注入</a></li><li><a href="/technology/invokechain-manage/invokechain-trace.html" class="sidebar-link">链路跟踪</a></li></ul></section></li><li><a href="/technology/logging.html" class="sidebar-link">日志追踪</a></li><li><a href="/technology/configuration.html" class="sidebar-link">配置中心</a></li><li><a href="/technology/message-queue-bus.html" class="sidebar-link">队列与消息总线</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>不可变基础设施</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group is-sub-group depth-1"><a href="/immutable-infrastructure/network" class="sidebar-heading clickable open"><span>网络</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/immutable-infrastructure/network/kubernetes-cni.html" class="sidebar-link">K8S的CNI网络</a></li><li><a href="/immutable-infrastructure/network/kubernetes-lb.html" class="sidebar-link">K8S的负载均衡</a></li></ul></section></li><li><a href="/immutable-infrastructure/storage.html" class="sidebar-link">共享存储</a></li><li><a href="/immutable-infrastructure/gpu-support.html" class="sidebar-link">GPU虚拟化</a></li><li><a href="/immutable-infrastructure/hardware-schedule.html" class="sidebar-link">硬件资源调度</a></li></ul></section></li><li><section class="sidebar-group depth-0"><a href="/release" class="sidebar-heading clickable"><span>产品发布准备</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/release/build-script.html" class="sidebar-link">构建发布脚本</a></li><li><a href="/release/continuous-integration.html" class="sidebar-link">持续集成</a></li><li><a href="/release/gated-launch.html" class="sidebar-link">灰度发布</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="√-服务设计风格">√ 服务设计风格</h1> <p>在软件业发展的初期，程序编写都是以算法为核心的，程序员会把数据和过程分别作为独立的部分来考虑，数据代表问题空间中的客体，程序代码则用于处理这些数据，这种思维方式直接站在计算机的角度去抽象问题和解决问题，被称为面向过程的编程思想。与此相对，面向对象的编程思想则站在现实世界的角度去抽象和解决问题，它把数据和行为都看作是对象的一部分，这样可以让程序员能以符合现实世界的思维方式来编写和组织程序。</p> <p>这两种思想有出现的向后顺序，但在一件人类使用计算机语言来处理数据的工作中，无论提倡以计算机的思维还是提倡以人类的思维来思考问题，这都是合乎逻辑的，并不应该是评价它们先进性的标准。</p> <p>12年一轮回，经过了上世纪90年代末到21世纪初期面向对象编程的火热之后，又出现了另一种新的考虑如何对内封装逻辑、对外重用服务的思想：面向资源的编程思想。这种新思想是把问题空间中的数据对象作为抽象的主题，把解决问题时从输入数据到输出结果的处理过程，看作是一个（组）数据对象的状态不断发生变换而导致的结果。这种思想有其生根的土壤基础：在跨越进程、跨越网络主机、跨越编程语言的分布式系统中，人们尝试过将之前在单进程应用里行之有效的面向过程、面向对象的服务设计方法改造迁移，使之适应分布式环境，这项工作总体上获得了成功，但在分布式环境里多少还是出现了一些新瑕疵，所以为另一种服务设计风格，即面向资源的编程思想留出了成长的空间。</p> <p>尽管在2020年还谈论什么RESTful、RPC，大概是确实有点落伍了，可这个问题是一个架构设计者必须有明确取舍权衡的重要技术决策，今天笔者仍准备来谈一下这个话题。</p> <h2 id="远程服务调用">远程服务调用</h2> <p>分布式系统各个节点中的机器大都通过特定的网络协议（HTTP、TCP等公有协议或<a href="https://zh.wikipedia.org/wiki/Java%E8%BF%9C%E7%A8%8B%E6%96%B9%E6%B3%95%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">JRMP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>、<a href="https://zh.wikipedia.org/wiki/%E9%80%9A%E7%94%A8%E5%AF%B9%E8%B1%A1%E8%AF%B7%E6%B1%82%E4%BB%A3%E7%90%86%E9%97%B4%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">GIOP<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>这样专有协议）相互访问，但网络协议只是负责往目标机器发送了一段文本或二进制的数据，为了建立可靠的服务，还有很多问题需要抽象：</p> <ul><li>服务所需的参数，服务返回的结果以什么格式传输？</li> <li>服务变化了，如何兼容前后不同版本的格式？</li> <li>如何提高网络利用的效率，譬如连接是否可被多个请求复用以减少开销？多个请求是否可以同时发往一个连接上?</li> <li>如何提高数据序列化的效率？</li> <li>如何保证网络的可靠性？譬如调用期间某个链接忽然断开了怎么办？</li> <li>怎样进行异常处理？异常该如何让调用者获知？</li> <li>万一发送的请求服务端不回复该怎么办？</li> <li>……</li></ul> <p>早在1988年，绝大多数人都对分布式、远程服务没有什么概念的时候（这话我说轻了，说那时候多数人对计算机没什么概念都不嫌过分），Sun Microsystems就起草并向IETF提交了<a href="https://tools.ietf.org/html/rfc1050" target="_blank" rel="noopener noreferrer">RFC 1050<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>规范，正式提出了远程服务调用（Remote Procedure Call，RPC）的概念，并设计了一套面向C语言的RPC协议（最后并没有什么人采用）。</p> <div class="quote"><p class="title">远程服务调用</p><p>Remote Procedure Call is a protocol that one program can use to request a service from a program located in another computer on a network without having to understand the network's details. A procedure call is also sometimes known as a function call or a subroutine call.</p></div><p>1991年，万维网还没正式诞生的年代，<a href="https://zh.wikipedia.org/wiki/%E5%AF%B9%E8%B1%A1%E7%AE%A1%E7%90%86%E7%BB%84%E7%BB%87" target="_blank" rel="noopener noreferrer">对象管理组织<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Object Management Group，OMG）发布了跨进程、面向异构语言的服务调用协议：CORBA 1.0（Common Object Request Broker Architecture，1.0版本只提供了C语言的调用）。到1997年发布的CORBA 2.0版本，CORBA支持了C、C++、Java（1998年新加入的Java语言映射）等主流编程语言，这是第一套由国际标准组织牵头，多个主流软件提供商共同参与的分布式规范，当时影响力只有微软私有的<a href="https://zh.wikipedia.org/wiki/Distributed_COM" target="_blank" rel="noopener noreferrer">DCOM<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>可以与之竞争。</p> <p>不过，CORBA与DCOM都没有获得真正的胜利，在1999年末，SOAP 1.0（Simple Object Access Protocol）规范的发布。SOAP是由微软和DevelopMentor共同起草的远程服务标准，随后提交给W3C成为国际标准，SOAP使用XML作为远程过程调用的编码载体（实际上并不绑定于XML-RPC，有SOAP Over UDP这类其他载体的应用），当时XML是计算工业最新的银弹，几乎所有只要是定义为XML的东西都是好的，连微软自己都主动放弃了DCOM转投SOAP。</p> <p>SOAP没有天生属于哪家公司的烙印，商业运作非常成功，很受市场欢迎，大量的厂商都想分一杯羹。但从技术角度来看，SOAP设计得并不优秀，甚至可以说是有显著缺陷的。对于开发者而言，SOAP最大的缺点是它那过于严格的规范定义，需要专门的客户端去调用和解析SOAP，也需要专门的服务去部署SOAP（如Apache Axis/CXF）。SOAP协议家族中，除它本身外包括了服务描述的<a href="https://zh.wikipedia.org/wiki/WSDL" target="_blank" rel="noopener noreferrer">Web服务描述标准<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Web Service Description Language，WSDL）协议、服务发现的<a href="https://zh.wikipedia.org/wiki/UDDI" target="_blank" rel="noopener noreferrer">统一描述、发现和集成<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Universal Description / Discovery and Integration，UDDI）协议、还有一堆几乎谁都说不清有多少个的<a href="https://zh.wikipedia.org/wiki/Web%E6%9C%8D%E5%8A%A1%E8%A7%84%E8%8C%83%E5%88%97%E8%A1%A8" target="_blank" rel="noopener noreferrer">WS-*<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>的子功能协议，对开发者来说都是很大的学习负担。</p> <p>人们对SOAP的热情迅速兴起，又逐渐冷却之后，远程服务器调用这个小小领域，开始进入了群雄混战、百家争鸣的战国时代，且延续至今。相继出现了RMI（Sun/Oracle）、Thrift（Facebook）、Dubbo（阿里巴巴）、gRPC（Google）、Motan2（新浪）、Finagle（Twitter）、brpc（百度）、Arvo（Hadoop）、JSON-RPC 2.0（公开规范，JSON-RPC工作组）等等一系列的协议/框架。这些框架功能、特点各不相同，有的是某种语言私有，有的能支持跨越多门语言，有的运行在HTTP协议之上，有的能直接运行于TCP/UDP之上的，但总体而言，RPC在朝着三个主要方向发展：</p> <ul><li>朝着<strong>对象</strong>发展，不满足于RPC将面向过程的编码方式带到分布式，希望在分布式系统中也能够进行跨进程的面向对象编程，代表为RMI、.NET Remoting，之前的CORBA和DCOM也可以归入这类，这条线有一个别名叫做<a href="https://en.wikipedia.org/wiki/Distributed_object" target="_blank" rel="noopener noreferrer">分布式对象<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（Distributed Object）。</li> <li>朝着<strong>效率</strong>发展，代表为gRPC和Thrift，传输效率（主要是Payload所占传输数据的比例大小，使用的传输协议和协议的设计都会影响到这点）和序列化效率的影响是最大的，gRPC和Thrift都有自己优秀的私有序列化器，传输协议一个是HTTP2，支持多路复用和头压缩，另一个直接基于TCP。</li> <li>朝着<strong>简化</strong>发展，代表为JSON-RPC，说要选速度最快的RPC可能会有争议，但选速度最慢的，JSON-RPC大概是逃不了的。牺牲了功能和效率，换来的是协议的简单，接口与格式都更为通用。</li></ul> <p>不同的RPC框架所提供的不同特性多少是有矛盾的，很难有某一种框架说“我全部都要”。譬如，要把面向对象那套全搬过来，就注定不会太简单（如建Stub、Skeleton就很烦了）；功能多起来，协议就要弄得复杂，效率一般就会受影响；要简单易用，那很多事情就必须遵循约定而不是配置才行；要重视效率，那就需要采用二进制的序列化器和较底层的传输协议，支持的语言范围容易受限。</p> <p>也正是每一种RPC框架都有不完美的地方，所以才导致不断有新的RPC出现，也导致了新想法的出现，REST便有了它诞生的土壤。</p> <h2 id="restful服务">RESTful服务</h2> <p>REST是这篇文章内定的主角，无论是思想上、概念上还是应用目标上，它与各种RPC协议只能算是有关联，但本质上并不是同一种东西。思想上的不同之前已经提到过，面向过程的编程思想与面向资源的编程思想，什么是面向资源编程，稍后我们再谈。</p> <p>而概念上不同是指REST并不是一种远程服务调用协议，甚至都可以把定语去掉，它就不是一种协议。协议都带有一定的规范性和强制性，至少也得有个文档吧，JSON-RPC再简单，也要有个《<a href="https://www.jsonrpc.org/specification" target="_blank" rel="noopener noreferrer">JSON-RPC Specification<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》来规定它的格式细节、异常、响应码等信息，但REST并没有这些东西，尽管有一些指导原则，但实际上不受约束。常有人批评某个服务“设计得不是RESTful”，其实这句话本身就没有正确地理解REST，这一点我们也将在稍后详细讨论。</p> <p>至于应用目标，REST与RPC在范围上是确有重合的，但实际上重合的区域并不大。上面列举的RPC三个方向中，分布式对象这一条线的应用与REST可以说是毫无关系；而重视”效率“这个方向的应用，基本上就限制了只能是后端应用（前端应用对于网络协议、序列化器这两点都没有选择的余地，想要高效率也有心无力），在分布式服务各个后端节点之间通讯这一块，REST虽然照样可以用于任何语言（只要有个HTTP Client就可以用）之间的调用，但其实在需要“效率”的纯后端应用场景里REST使用率真算不得高。我们开发的REST服务，可能有百分之八九十是提供给前端去消费的。而在前端这一块，最多也就是JSON-RPC有机会和REST产生竞争，其他所有RPC框架，哪怕是支持HTTP协议，哪怕提供了JavaScript版本的客户端（如gRPC），也是为了去支持node.js，没见过有谁把它们用到浏览器上的。</p> <p>但尽管有如此多的不同，这两者还是产生了很多的比较与争论，就如同当年面向对象与面向过程一样，非得争出个高低不可。网上许多REST vs RPC的口水仗中说REST不好的，通常也并不是支持哪个RPC框架/协议比它好用，大多都只是不赞成REST的设计风格，心中说的本意其实是“面向资源编程”的思想不好，不如“面向过程编程”来得好用好理解。</p> <h3 id="理解rest">理解REST</h3> <p>个人会有好恶偏爱，但计算机科学是务实的，有了面向过程之后，还能产生面向资源，并引起广泛的关注、使用和讨论，后者一定是有一些面向过程没有的闪光点，或者解决/避免了一些面向过程中的缺陷。我们不妨先去理解REST为什么出现、解决什么问题、方法是什么，然后再来评价它。</p> <p>许多人都知道REST源于Roy Thomas Fielding在2000年发表的博士论文：《<a href="https://www.ics.uci.edu/~fielding/pubs/dissertation/top.htm" target="_blank" rel="noopener noreferrer">Architectural Styles and the Design of Network-based Software Architectures<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》，此文的确是REST的源头，但我们不能忽略Fielding的身份和之前工作的背景，这对理解REST的设计思想至关重要。</p> <p>首先，Fielding是一名很优秀的软件工程师，他是Apache服务器的核心开发者，后来成为了著名的Apache软件基金会的合作创始人；同时，Fielding也是HTTP 1.0协议（1996年发布）的专家组成员，后来还成为了HTTP 1.1协议（1999年发布）的负责人。HTTP 1.1协议设计的极为成功，以至于发布之后长达十年的时间里，都没有多少人认为有修订的必要。用来指导HTTP 1.1协议设计的理论和思想，最初是以备忘录的形式在专家组成员之间交流，除了IETF、W3C的专家外，并没有在外界广泛流传。</p> <div class="custom-block center"><p><img src="/assets/img/Roy_Thomas_Fielding.b48aa969.jpg" alt="">
Roy Thomas Fielding</p></div> <p>从时间上看，对HTTP 1.1协议的设计工作贯穿了Fielding的整个博士研究生涯，当起草HTTP 1.1协议的工作完成后，Fielding回到了加州大学欧文分校继续攻读自己的博士学位。第二年，他更为系统、严谨地阐述了这套理论框架，并且以这套理论框架导出了一种新的编程风格，他为这种风格取了一个很多人难以理解，但是今天已经广为人知的名字REST（<strong>Re</strong>presentational <strong>S</strong>tate <strong>T</strong>ransfer）“表征状态转移”的缩写。</p> <p>哪怕对编程和网络都很熟悉的同学，只从标题中也不太可能直接弄明白什么叫“表征”、啥东西的“状态”、从哪“转移”到哪。尽管在论文原文中确有论述这些概念，但写得确实相当晦涩（不想读英文的同学从此<a href="https://www.infoq.cn/article/2007/07/dlee-fielding-rest/" target="_blank" rel="noopener noreferrer">获得中文版本<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>），我推荐一种比较好的方式是先理解什么是HTTP，再配合一些实际例子来进行类比，你会发现“REST”实际上是“HTT”（<strong>H</strong>yper <strong>T</strong>ext <strong>T</strong>ransfer）的进一步抽象，两者就如同接口与实现类之间的关系一般。</p> <p>“超文本”一词是美国社会学家Theodor Holm Nelson在1967年于《<a href="https://archive.org/details/SelectedPapers1977" target="_blank" rel="noopener noreferrer">Brief Words on the Hypertext<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》一文中提出的，下面引用他本人在1992年修正后的定义：</p> <div class="quote"><p class="title">Hypertext</p><p>By now the word &quot;hypertext&quot; has become generally accepted for branching and responding text, but the corresponding word &quot;hypermedia&quot;, meaning complexes of branching and responding graphics, movies and sound – as well as text – is much less used. Instead they use the strange term &quot;interactive multimedia&quot;: this is four syllables longer, and does not express the idea of extending hypertext.</p> <div class="custom-block right"><p>—— Theodor Holm Nelson <a href="https://en.wikipedia.org/wiki/Literary_Machines" target="_blank" rel="noopener noreferrer"> Literary Machines<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>, 1992</p></div></div><p>以上描述了超文本（超媒体）是一种“能够对操作进行判断和响应的文本（或声音、图像等）”，这个概念在上世纪60年代提出时也许还属于科幻的范畴，但是今天大众已经完全接受了，互联网中一段文字可以点击、可以触发脚本执行、可以调用服务端，这毫不稀奇。那我们继续尝试从“超文本”或者“超媒体”的含义来理解什么是“表征”以及REST中其他关键概念：</p> <ul><li><p><strong>资源</strong>（Resource）：譬如你现在正在阅读一篇名为《服务设计风格》的文章，这篇文章中的内容本身（你将其视作是某种信息、数据）我们称之为“资源”。无论你是在网上看的网页、是打印出来的文字稿、是在电脑屏幕上阅读抑或是手机上浏览，尽管呈现的样子各不相同，但其中的信息是不变的，你所阅读的仍是同一个“资源”。</p></li> <li><p><strong>表征</strong>（Representation）：当你通过电脑浏览器阅读此文章时，浏览器向服务端发出请求“我需要这个资源的HTML格式”，服务端向浏览器返回的这个HTML，这就被称之为“表征”，你通过其他方式拿到的PDF、Markdown、RSS等其他形式，它们也同样是表征。可见表征这个概念与我们开发分层中常说的“表示层”（Presentation Layer）的语义其实是一致的。</p></li> <li><p><strong>状态</strong>（State）：当你把这篇文章阅读完毕，想看下一篇文章是什么内容的时候，你向服务器请求“给我下一篇文章”，但是“下一篇”是个相对概念，必须依赖“当前你正在阅读的文章是哪一篇”才能正确回应，这类在特定语境中才能产生、无法提前预置的上下文信息即为“状态”。我们所说的有状态（Stateful）还是无状态（Stateless），是只相对于服务端来说的，服务器要完成“取下一篇”的请求，要么自己记住用户的状态（这个用户现在阅读的是哪一篇文章，有状态），要么用户在请求的时候明确告诉服务器（我正在阅读某某文章，现在要读下一篇，无状态）。</p></li> <li><p><strong>转移</strong>（Transfer）：无论状态是由服务端还是客户端来提供的，“取下一篇文章”这个行为逻辑必然只能由服务端来提供。服务器通过某种方式，把“用户当前阅读的文章”转变成“下一篇文章”，这就被称为“<strong>表征状态转移</strong>”</p></li></ul> <p>借着这个故事的上下文，笔者顺便再介绍几个目前不涉及但稍后要用到的概念名词：</p> <ul><li><strong>统一接口</strong>（Uniform Interface）：上面说的“服务器通过某种方式”具体是什么方式？把文章拉倒结尾处，右下角有下一篇文章的<a href="https://zh.wikipedia.org/wiki/%E7%BB%9F%E4%B8%80%E8%B5%84%E6%BA%90%E6%A0%87%E5%BF%97%E7%AC%A6" target="_blank" rel="noopener noreferrer">URI<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>超链接地址，这是服务端渲染这篇文章时就预置好的，它就是所谓的“某种方式”。但URI的含义是同一资源标识符，如何能表达出“转移”的含义呢？HTTP协议中提前约定好了一套“统一接口”，包括：<strong>GET</strong>、<strong>HEAD</strong>、<strong>POST</strong>、<strong>PUT</strong>、<strong>DELETE</strong>、<strong>TRACE</strong>、<strong>OPTIONS</strong>七中操作，任何一个支持HTTP协议的服务器都会遵守，对特定的URI采取这些操作，服务器自然就会触发相应的表征状态转移。</li> <li><strong>超文本驱动</strong>（Hypertext Driven）：尽管表征状态转移是由浏览器主动向服务器发出请求，导致了“在我们浏览器的屏幕上显示出了下一篇文章的内容”这个结果的出现，但浏览器其实根本不知道系统中这套转移逻辑，它是根据请求首页时服务器给予的超文本内容，导航到了这篇文章，阅读结束时再导航到下一篇。浏览器作为所有网站的通用的客户端，以上所有行为都是不可能预置于浏览器之中，而是由服务器第一个请求中的返回信息（超文本）来驱动的。这点其实与带有客户端的软件有很本质的区别，那些软件中，业务逻辑是预置于客户端之中的。</li> <li><strong>自描述消息</strong>（Self-Descriptive Messages）：由于资源的表征可能多种形态，在消息中应当有明确的信息来告知客户端该消息的类型以及该如何处理该消息。一种被广泛采用的自描述方法在HTTP的Content-Type Header中标识出<a href="https://zh.wikipedia.org/wiki/%E4%BA%92%E8%81%94%E7%BD%91%E5%AA%92%E4%BD%93%E7%B1%BB%E5%9E%8B" target="_blank" rel="noopener noreferrer">互联网媒体类型<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>（MIME type），譬如“Content-Type:application/json;charset=utf-8”，则说明该资源会以JSON的格式来返回，请使用UTF-8字符集进行处理。</li></ul> <p>建立上面这些概念之后，我们就可以开始讨论面向资源的编程思想与REST所提出的六个具体的软件架构设计原则了。请注意，Fielding提出REST时所谈论的范围是“架构风格与网络的软件架构设计”（ Architectural Styles and Design of Network-based Software Architectures），而不是现在被人们所狭义理解的一种“服务（API）设计风格”，这两者的范围差别就好比icyfenix.cn整个网站所谈论的话题“现代软件架构探索”与本篇文章“服务设计风格”那样，前者是后者的一个很大的超集（出于本篇的主题，后文还是会从着重于“服务设计”的角度出发）。</p> <p>Fielding认为，一套理想的、完全满足REST的系统应该是这样的：</p> <ol><li><strong>服务端与客户端分离</strong>（Client-Server）<br>将用户界面所关注的逻辑和数据存储所关注的逻辑分离开来有助于提高用户界面的跨平台的可移植性，这一点正越来越受到广大开发者所认可，以前完全基于服务端控制和渲染的JSF这类框架实际用户已甚少，而在服务端进行界面控制（Controller），通过服务端或者客户端的模版渲染引擎来进行界面渲染（Render）的框架（Struts、SpringMVC）也受到了极大冲击。这一点主要推动力量与REST关系不大，前端技术（JavaScript、TypeScript等）的近年来的高速发展，使得前端能力大幅度加强才是主因。</li> <li><strong>无状态</strong>（Stateless）<br>这是REST的一条关键原则，在做服务API设计时，很多人觉得REST怎么设计都觉得别扭，很有可能的一个原因是在服务端持有着比较重的状态。REST希望服务器不负责维护状态，每一次从客户端发送的请求中，应包括所有的必须的状态信息，会话信息由客户端保存，服务器端根据这些状态信息来进行业务处理。当客户端可以切换到一个新状态的时候发送请求信息。当一个（组）请求被发送之后，客户端就处于一个状态变迁过程中，每一个应用的状态描述可以被客户端用来初始化下一次的状态变迁。<br>但必须承认的现状是，目前大多数的系统都达不到这个要求，越复杂、越大型的系统越是如此。服务端无状态可以在分布式环境中获得非常多的好处，但大型系统的上下文状态数量完全可能膨胀到让客户端在每次请求时提供变得不切实际的程度，在数据库、Session、集中式缓存等地方持有一定的状态成为一种实际广泛使用的折衷的方案。</li> <li><strong>可缓存</strong>（Cacheability）<br>无状态服务虽然提升了系统的可见性、可靠性和可伸缩性，但降低了系统的网络性。这句话通俗的解释就是，某个功能使用有状态的架构只需要一次请求就能完成，而无状态的服务则可能会需要多个请求。为了缓解这个矛盾，REST希望软件系统能够如同万维网一样，客户端和中间的通讯传递者（代理）可以将部分服务端的应答缓存起来。应答必须明确的或者间接的表明本身是否可以进行缓存，以预防客户端在将来进行请求的时候得到过时的数据。运作良好的缓存机制可以减少客户端-服务器之间的交互, 甚至完全避免客户端-服务器交互，这进一步提了高性能。</li> <li><strong>分层系统</strong>（Layered System）<br>这里所指的并不是展示层、服务层、持久层这种意义上的分层。而是指客户端一般不需要知道是否直接连接到了最终的服务器，或者是路径上的中间服务器。中间服务器可以通过负载均衡和共享缓存的机制提高系统的可扩展性，这样可也便于安全策略的部署。譬如典型的应用是内容分发网络（CDN），你现在访问这个站点，一般（如果你在中国国境内的话）都并不是直接访问位于GitHub Pages的服务器，而是位于腾讯云的CDN，但你并不需要感知到这一点。</li> <li><strong>统一接口</strong>（Uniform Interface）<br>这是REST的另一条关键原则，RERT希望面向资源编程，希望设计软件系统的核心放在抽象系统有哪些资源，而不是系统有哪些行为（服务）。对资源的操作是可数的、固定的、统一的，由于REST并没有设计新的协议，所以这些操作都借用了HTTP协议中固有的操作命令。<br>这一点也是REST最容易陷入争论的地方，基于网络的软件系统，到底是面向资源更好，还是面向服务更好，这事情哪怕到了今天仍然是没有个定论，也许永远都没有。但是，有一个基本清晰的结论是，面向资源编程是的抽象程度更高，这意味着坏处是往往距离人类的思维方式更远，而好处是往往通用程度会更高。这句话大概本身就挺抽象的，我举个例子，譬如几乎每个系统都有的登录和注销功能，如果你理解成登录对应于login()服务，注销对应于logout()服务这样两个服务，这是“符合人类思维”；如果你理解成登录是CREATE Session，注销是REMOVE Session，这样你只需要设计一个Session资源即可满足，甚至以后对Session的其他需求，譬如查询或者修改登陆用户的信息，都可以在这一套设计中囊括在内，这便是“抽象程度更高”。<br>要在架构设计中合适地利用统一接口，Fielding系统应能做到每次请求中都包含资源的ID，通过资源ID来进行操作，每个资源都应该是自描述的消息，通过超文本来驱动应用状态的转移。</li> <li><strong>按需代码</strong>（<a href="https://en.wikipedia.org/wiki/Code_on_demand" target="_blank" rel="noopener noreferrer">Code-On-Demand<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>）<br>这被Fielding列为一条可选原则。按需代码指任何按照客户端软件（譬如浏览器）的请求，将可执行的软件程序从服务器计算机发送到客户端的技术。这是可选的原因并非是它特别难以达到，而是出于必要性。举个例子，譬如你使用Element-UI组件库开发一个Web应用，但其实只用了里面一两个组件，却没有好好配置<a href="https://github.com/QingWei-Li/babel-plugin-component" target="_blank" rel="noopener noreferrer">babel-plugin-component<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>来做按需引入，把几十个组件都打包进去，这便是没有做到按需代码的原则。这种事情挺普遍的，但我个人并不赞成不考虑实际场景的唯性能论，在关键场景肯定要抠细节，但所有场景都无限度的“精益求精”并无必要。</li></ol> <p>REST的基本思想是面向资源来抽象问题，基本手段是尽可能复用HTTP协议中已经定义的语义和相关基础支持来解决问题，以上六个原则都是在这个指导思路下设计的。因为HTTP本来就是面向资源而设计的网络协议，只要面向资源的软件架构确实行得通的话，本文开篇中所列的“远程服务调用需要考虑的问题”便几乎不再需要独立考虑了，HTTP协议已经有效运作了30年，其相关的技术基础设施已是千锤百炼，无比成熟，这些问题早已解决过。唯一需要考虑的是你的软件系统、设计和开发人员是否能够适应面向资源的思想来设计软件，来编写代码。</p> <h3 id="rmm成熟度">RMM成熟度</h3> <p>https://martinfowler.com/articles/richardsonMaturityModel.html</p> <p>CN： https://blog.csdn.net/dm_vincent/article/details/51341037</p> <h3 id="graphql">GraphQL</h3> <p>REST只提供了增删改查的基本语义，其他的语义基本上不管。比如批量添加，批量删除</p> <p>不能说 GraphQL 是要完全取代 REST，因为前者只是一个工具，而 REST 是一种架构模式</p></div> <footer class="page-edit"><div class="edit-link"><a href="https://github.com/fenixsoft/awesome-fenix/edit/master/architect-perspective/general-architecture/api-style.md" target="_blank" rel="noopener noreferrer">在GitHub中编辑</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="last-updated"><span class="prefix">最后更新:</span> <span class="time">3/28/2020, 9:40:06 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/deployment/operation-env-setup/devops-setup.html" class="prev">
        在K8S上部署DevOps
      </a></span> <span class="next"><a href="/architect-perspective/general-architecture/system-security.html">
        √ 安全架构
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.ebee20fc.js" defer></script><script src="/assets/js/2.d5b46b4e.js" defer></script><script src="/assets/js/9.77c59a10.js" defer></script>
  </body>
</html>
